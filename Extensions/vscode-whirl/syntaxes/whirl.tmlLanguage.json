{
   "$schema": "https://raw.githubusercontent.com/martinring/tmlanguage/master/tmlanguage.json",
   "name": "Whirl",
   "patterns": [
      { "include": "#comment" },
      { "include": "#string_literal" },
      { "include": "#type_declaration" },
      { "include": "#model_header" },
      { "include": "#trait_header" },
      { "include": "#use_declaration" },
      { "include": "#enum_declaration" },
      { "include": "#enum_variant_hover" },
      { "include": "#trait_implementation" },
      { "include": "#function" },
      { "include": "#boolean_literal" },
      { "include": "#keyword" },
      { "include": "#number" },
      { "include": "#injunction" },
      { "include": "#this" },
      { "include": "#inferred_model" },
      { "include": "#inferred_function" },
      { "include": "#type_label" },
      { "include": "#identifier" }
   ],
   "repository": {
      "keyword": {
         "name": "keyword.control entity.name.keyword support.keyword",
         "match": "\\b(for|function|fn|in|while|break|continue|if|else|as|return|switch|case)\\b"
      },
      "injunction": {
         "name": "meta.injunction keyword.storage.injunction",
         "match": "\\b(use|enum|public|static|test|var|new|const|model|async|record|trait|type|extends|implements|not|and|or|is)\\b"
      },
      "comment": {
         "patterns": [
            { "include": "#block_comment" },
            { "include": "#line_comment" }
         ]
      },
      "block_comment": {
         "name": "comment.block",
         "begin": "\\/\\*",
         "end": "\\*\\/"
      },
      "line_comment": {
         "name": "comment.line",
         "begin": "//",
         "end": "\n"
      },
      "string_literal": {
         "patterns": [
            { "include": "#single_quote_string" },
            { "include": "#double_quote_string" }
         ]
      },
      "single_quote_string": {
         "name": "string.quoted meta.string",
         "begin": "\\'",
         "patterns": [
            { "include": "#string_character_escape" },
            { "include": "#string_template_expression" }
         ],
         "end": "\\'"
      },
      "double_quote_string": {
         "name": "string.quoted meta.string",
         "begin": "\"",
         "patterns": [
            { "include": "#string_character_escape" },
            { "include": "#string_template_expression" }
         ],
         "end": "\""
      },
      "string_character_escape": {
         "name": "constant.character.escape",
         "match": "\\\\(x[\\dA-Fa-f]{2}|u([\\dA-Fa-f]{4}|\\{[\\dA-Fa-f]+\\})|[0-2][0-7]{0,2}|(3[0-6]|37|[4-7])[0-7]?|.)"
      },
      "string_template_expression": {
         "name": "meta.template.expression",
         "begin": "(\\{)",
         "beginCaptures": {
            "1": {
               "name": "punctuation.expression.embedded-expression-start constant.language.embedded.start"
            }
         },
         "patterns": [{ "include": "$self" }],
         "end": "(\\})",
         "endCaptures": {
            "1": {
               "name": "punctuation.expression.embedded-expression-end constant.language.embedded.end"
            }
         }
      },
      "number": {
         "patterns": [
            {
               "name": "constant.numeric.hex",
               "match": "\\b(?<!\\$)0(?:x|X)[\\dA-Fa-f]+(n)?\\b(?!\\$)"
            },
            {
               "name": "constant.numeric.octal",
               "match": "\\b(?<!\\$)0(?:o|O)[0-7]+(n)?\\b(?!\\$)"
            },
            {
               "name": "constant.numeric.binary",
               "match": "\\b(?<!\\$)0(?:b|B)[0-1]+(n)?\\b(?!\\$)"
            },
            {
               "name": "constant.numeric.decimal",
               "match": "\\b\\d+((\\.\\d+)|n)?\\b(?!\\$)"
            },
            {
               "name": "constant.numeric.exponent",
               "match": "\\b\\d+e\\d+\\b(?!\\$)"
            }
         ]
      },

      "type_declaration": {
         "begin": "(\\btype\\s+)",
         "beginCaptures": {
            "1": {
               "name": "keyword"
            }
         },
         "patterns": [
            { "include": "#comment" },
            {
               "begin": "(?<=type\\s+)",
               "contentName": "meta.class class entity.name.class",
               "end": "(?=[^\\w])"
            },
            { "include": "#generic_params" },
            {
               "match": "\\s*\\=\\s*"
            },
            {
               "include": "#type_expression"
            }
         ],
         "end": "(?=;)"
      },

      "model_header": {
         "begin": "(\\bmodel\\s+)",
         "beginCaptures": {
            "1": {
               "name": "keyword"
            }
         },
         "patterns": [
            { "include": "#comment" },
            {
               "begin": "(?<=model\\s+)",
               "contentName": "meta.class class entity.name.class",
               "end": "(?=[^\\w])"
            },
            { "include": "#generic_params" },
            { "include": "#implements_label" }
         ],
         "end": "(?=\\{)"
      },
      "implements_label": {
         "begin": "(\\bimplements\\s+)",
         "beginCaptures": {
            "1": {
               "name": "keyword"
            }
         },
         "patterns": [
            { "include": "#comment" },
            { "include": "#type_expression" },
            { "include": "#punctuation_comma" }
         ],
         "end": "(?=[^,\\.\\w\\s\\<\\>]|extends\\s+)"
      },
      "trait_header": {
         "begin": "(\\btrait\\s+)",
         "beginCaptures": {
            "1": {
               "name": "keyword"
            }
         },
         "patterns": [
            { "include": "#comment" },
            {
               "begin": "(?<=trait\\s+)",
               "contentName": "meta.class class entity.name.class",
               "end": "(?=[^\\w])"
            },
            { "include": "#generic_params" },
            { "include": "#implements_label" }
         ],
         "end": "(?=\\{)"
      },

      "use_declaration": {
         "begin": "(\\buse\\b\\s+)",
         "beginCaptures": {
            "1": {
               "name": "keyword"
            }
         },
         "patterns": [
            {
               "name": "entity.name.class support.class",
               "match": "(\\b\\w+\\b)"
            },
            { "match": "\\." },
            { "match": "\\{\\}" }
         ],
         "end": "(?=;)"
      },

      "enum_declaration": {
         "begin": "(\\benum\\b)\\s+",
         "beginCaptures": {
            "1": {
               "name": "keyword"
            }
         },
         "patterns": [
            {
               "begin": "(?<=enum\\s+)",
               "contentName": "meta.class class entity.name.class",
               "end": "(?=[^\\w])"
            },
            { "include": "#enum_block" }
         ],
         "end": "\\s*\\}"
      },
      "enum_variant_hover": {
         "begin": "(\\(variant\\))\\s+",
         "beginCaptures": {
            "1": {
               "name": "identifier meta.identifier variable.identifier"
            }
         },
         "patterns": [
            { "include": "#inferred_function" },
            { "include": "#type_expression" }
         ],
         "end": "\\s*\\}"
      },
      "enum_block": {
         "begin": "\\{\\s*",
         "patterns": [
            { "include": "#comment" },
            { "include": "#enum_variant_simple" },
            { "match": "\\," },
            { "include": "#enum_variant_tagged" }
         ],
         "end": "(?=\\s*\\})"
      },
      "enum_variant_simple": {
         "name": "meta.definition.variable variable.other.constant",
         "match": "\\b\\w+\\b\\s*"
      },
      "enum_variant_tagged": {
         "begin": "(\\s*\\w+\\s*)(?=\\()",
         "beginCaptures": {
            "1": {
               "name": "meta.definition.variable variable.other.constant"
            }
         },
         "patterns": [
            { "include": "#comment" },
            { "include": "#type_expression" }
         ],
         "end": "(?=\\s*\\))"
      },
      "trait_implementation": {
         "name": "entity.name.function support.function",
         "match": "\\b(function)\\s+(\\[(\\s*\\w+\\s*(\\<.*\\>)?\\s*\\.)+\\s*)\\w+(?=\\s*\\]\\s*(\\<.*\\>)?\\s*\\()",
         "captures": {
            "1": {
               "patterns": [{ "name": "keyword.control", "match": "\\w+" }]
            },
            "2": {
               "patterns": [
                  {
                     "name": "entity.name.class support.class",
                     "match": "\\w+"
                  },
                  { "match": "\\." }
               ]
            }
         }
      },
      "function": {
         "begin": "(\\bfunction\\s+)",
         "beginCaptures": {
            "1": {
               "name": "keyword.control"
            }
         },
         "patterns": [
            {
               "begin": "(?<=function\\s+)",
               "contentName": "support.function entity.name.function",
               "end": "(?=[^\\w])"
            },
            { "include": "#generic_params" },
            { "include": "$self" }
         ],
         "end": "(?=\\))"
      },

      "inferred_model": {
         "name": "meta.class class entity.name.class",
         "match": "\\b((?<=\\bnew\\s+(\\w+\\s*\\.)*\\s*)\\w+\\b)"
      },
      "inferred_function": {
         "name": "entity.name.function support.function",
         "match": "\\w+(?=\\s*(\\<.*\\>)?\\s*\\()",
         "captures": {
            "1": {
               "patterns": [{ "include": "#generic_args" }]
            }
         }
      },
      "import_punctuation": {
         "name": "punctuation.expression",
         "match": "\\{|\\}|\\,|\\."
      },
      "type_label": {
         "begin": "\\:\\s*",
         "patterns": [{ "include": "#type_expression" }],
         "end": "(?=[^\\s|^\\w|\\_|\\.|\\<|\\>|,])|(,(?=\\s*(\\w|_)+\\s*\\??\\s*(\\:|\\))))"
      },
      "discrete_type": {
         "patterns": [
            { "include": "#type_name" },
            { "include": "#generic_args" }
         ]
      },
      "type_name": {
         "name": "support.type entity.name.type",
         "match": "\\b\\w+\\b"
      },
      "type_expression": {
         "patterns": [
            {
               "name": "constant.language",
               "match": "\\s*This\\s*"
            },
            { "include": "#function_type" },
            {
               "patterns": [{ "include": "#discrete_type" }, { "match": "\\." }]
            }
         ]
      },
      "function_type": {
         "begin": "(\\bfn\\b)",
         "beginCaptures": {
            "1": {
               "name": "keyword.control"
            }
         },
         "patterns": [{ "include": "#generic_params" }, { "include": "$self" }],
         "end": "(?=\\))"
      },
      "generic_args": {
         "begin": "(?<=\\<\\s*)",
         "patterns": [
            { "include": "#type_expression" },
            { "include": "#generic_args" }
         ],
         "end": "(?=\\>)"
      },
      "generic_params": {
         "begin": "(?<=\\<\\s*)",
         "patterns": [
            {
               "name": "constant.language",
               "match": "\\bThis\\b"
            },
            { "include": "#type_name" },
            { "include": "#type_label" },
            { "include": "#punctuation_comma" }
         ],
         "end": "(?=\\>)"
      },

      "this": {
         "name": "constant.language",
         "match": "\\bthis\\b"
      },
      "identifier": {
         "patterns": [
            {
               "name": "entity variable",
               "match": "\\b\\w+(?=\\.)\\b"
            },
            {
               "name": "meta.definition.variable variable.other.constant",
               "match": "\\b[[:upper:][:digit:]_]+\\b"
            },
            {
               "name": "identifier meta.identifier variable.identifier",
               "match": "\\w+"
            }
         ]
      },
      "boolean_literal": {
         "name": "constant.language.literal",
         "match": "\\b(true|false)\\b"
      },

      "punctuation_comma": {
         "name": "punctuation.separator.comma.ts",
         "match": ","
      }
   },
   "scopeName": "source.wrl"
}
