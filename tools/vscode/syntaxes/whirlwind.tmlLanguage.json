{
   "$schema": "https://raw.githubusercontent.com/martinring/tmlanguage/master/tmlanguage.json",
   "name": "Whirlwind",
   "patterns": [
      { "include": "#comment" },
      { "include": "#string_literal" },
      { "include": "#type_declaration" },
      { "include": "#model_header" },
      { "include": "#interface_header" },
      { "include": "#module_declaration" },
      { "include": "#use_declaration" },
      { "include": "#enum_declaration" },
      { "include": "#enum_variant_hover" },
      { "include": "#interface_implementation" },
      { "include": "#function" },
      { "include": "#boolean_literal" },
      { "include": "#keyword" },
      { "include": "#number" },
      { "include": "#injunction" },
      { "include": "#this" },
      { "include": "#inferred_model" },
      { "include": "#inferred_function" },
      { "include": "#type_label" },
      { "include": "#identifier" }
   ],
   "repository": {
      "keyword": {
         "name": "entity.name.keyword support.keyword keyword.control",
         "match": "\\b(for|function|fn|in|while|break|continue|if|else|as|return|switch|case)\\b"
      },
      "injunction": {
         "name": "meta.injunction keyword.storage.injunction",
         "match": "\\b(use|module|enum|public|static|test|var|new|const|model|async|record|interface|type|implements|not|and|or|is|super|core|packages)\\b"
      },
      "comment": {
         "patterns": [
            { "include": "#block_comment" },
            { "include": "#line_comment" }
         ]
      },
      "block_comment": {
         "name": "comment.block",
         "begin": "\\/\\*",
         "end": "\\*\\/"
      },
      "line_comment": {
         "name": "comment.line",
         "begin": "//",
         "end": "\n"
      },
      "string_literal": {
         "patterns": [
            { "include": "#single_quote_string" },
            { "include": "#double_quote_string" },
            { "include": "#template_literal" }
         ]
      },
      "single_quote_string": {
         "name": "string.quoted meta.string",
         "begin": "\\'",
         "patterns": [
            { "include": "#string_character_escape" },
            { "include": "#string_template_percent" }
         ],
         "end": "\\'"
      },
      "double_quote_string": {
         "name": "string.quoted meta.string",
         "begin": "\"",
         "patterns": [
            { "include": "#string_character_escape" },
            { "include": "#string_template_percent" }
         ],
         "end": "\""
      },
      "string_character_escape": {
         "name": "constant.character.escape",
         "match": "\\\\(x[\\dA-Fa-f]{2}|u([\\dA-Fa-f]{4}|\\{[\\dA-Fa-f]+\\})|[0-2][0-7]{0,2}|(3[0-6]|37|[4-7])[0-7]?|.)"
      },
      "string_template_percent": {
         "name": "meta.template.expression constant.numeric",
         "match": "\\%(\\{[^\\}]*\\})?"
      },
      "template_literal": {
         "name": "string.quoted meta.string",
         "begin": "`",
         "patterns": [
            { "include": "text.html.basic" },
            { "include": "#string_character_escape" },
            { "include": "#string_template_percent" }
         ],
         "end": "`"
      },
      "number": {
         "patterns": [
            {
               "name": "constant.numeric.hex",
               "match": "\\b(?<!\\$)0(?:x|X)[\\dA-Fa-f]+(n)?\\b(?!\\$)"
            },
            {
               "name": "constant.numeric.octal",
               "match": "\\b(?<!\\$)0(?:o|O)[0-7]+(n)?\\b(?!\\$)"
            },
            {
               "name": "constant.numeric.binary",
               "match": "\\b(?<!\\$)0(?:b|B)[0-1]+(n)?\\b(?!\\$)"
            },
            {
               "name": "constant.numeric.decimal",
               "match": "\\b\\d+((\\.\\d+)|n)?\\b(?!\\$)"
            },
            {
               "name": "constant.numeric.exponent",
               "match": "\\b\\d+e\\d+\\b(?!\\$)"
            }
         ]
      },

      "type_declaration": {
         "begin": "(\\btype\\s+)",
         "beginCaptures": {
            "1": {
               "name": "keyword"
            }
         },
         "patterns": [
            { "include": "#comment" },
            {
               "begin": "(?<=type\\s+)",
               "contentName": "meta.class class entity.name.class",
               "end": "(?=[^[A-Za-z0-9]])"
            },
            { "include": "#generic_params" },
            {
               "match": "\\s*\\=\\s*"
            },
            {
               "include": "#type_expression"
            }
         ],
         "end": "(?=;)"
      },

      "model_header": {
         "begin": "(\\bmodel\\s+)",
         "beginCaptures": {
            "1": {
               "name": "keyword"
            }
         },
         "patterns": [
            { "include": "#comment" },
            {
               "begin": "(?<=model\\s+)",
               "contentName": "meta.class class entity.name.class",
               "end": "(?=[^[A-Za-z0-9]])"
            },
            { "include": "#generic_params" },
            { "include": "#implements_label" },
            { "include": "$self" }
         ],
         "end": "(?=\\{)"
      },
      "implements_label": {
         "begin": "(\\bimplements\\s+)",
         "beginCaptures": {
            "1": {
               "name": "keyword"
            }
         },
         "patterns": [
            { "include": "#comment" },
            { "include": "#type_expression" },
            {
               "name": "punctuation",
               "match": "\\+"
            },
            { "include": "#punctuation_comma" }
         ],
         "end": "(?={)"
      },
      "interface_header": {
         "begin": "(\\binterface\\s+)",
         "beginCaptures": {
            "1": {
               "name": "keyword"
            }
         },
         "patterns": [
            { "include": "#comment" },
            {
               "begin": "(?<=interface\\s+)",
               "contentName": "meta.class class entity.name.class",
               "end": "(?=[^[A-Za-z0-9]])"
            },
            { "include": "#generic_params" },
            { "include": "#implements_label" },
            { "include": "$self" }
         ],
         "end": "(?=\\{)"
      },

      "module_declaration": {
         "match": "(\\bmodule\\b\\s+)([A-Za-z0-9\\.\\_]+)",
         "captures": {
            "1": {
               "name": "keyword"
            },
            "2": {
               "name": "entity.name.class support.class"
            }
         }
      },

      "use_declaration": {
         "begin": "(\\buse\\b\\s+)",
         "beginCaptures": {
            "1": {
               "name": "keyword"
            }
         },
         "patterns": [
            { "include": "#comment" },
            { "include": "#injunction" },
            {
               "name": "meta.definition.variable variable.other.constant",
               "match": "\\b[[:upper:][:digit:]_]+\\b"
            },
            {
               "name": "entity.name.class support.class",
               "match": "(\\b[A-Za-z0-9]+\\b)"
            },
            { "match": "\\." },
            { "match": "\\{\\}" }
         ],
         "end": "(?=;)"
      },

      "enum_declaration": {
         "begin": "(\\benum\\b)\\s+",
         "beginCaptures": {
            "1": {
               "name": "keyword"
            }
         },
         "patterns": [
            {
               "begin": "(?<=enum\\s+)",
               "contentName": "meta.class class entity.name.class",
               "end": "(?=[^[A-Za-z0-9]])"
            },
            { "include": "#enum_block" }
         ],
         "end": "\\s*\\}"
      },
      "enum_variant_hover": {
         "begin": "(\\(variant\\))\\s+",
         "beginCaptures": {
            "1": {
               "name": "identifier meta.identifier variable.identifier"
            }
         },
         "patterns": [
            { "include": "#inferred_function" },
            { "include": "#type_expression" }
         ],
         "end": "\\s*\\}"
      },
      "enum_block": {
         "begin": "\\{\\s*",
         "patterns": [
            { "include": "#comment" },
            { "include": "#enum_variant_simple" },
            { "match": "\\," },
            { "include": "#enum_variant_tagged" }
         ],
         "end": "(?=\\s*\\})"
      },
      "enum_variant_simple": {
         "name": "meta.definition.variable variable.other.constant",
         "match": "\\b[A-Za-z0-9]+\\b\\s*"
      },
      "enum_variant_tagged": {
         "begin": "(\\s*[A-Za-z0-9]+\\s*)(?=\\()",
         "beginCaptures": {
            "1": {
               "name": "meta.definition.variable variable.other.constant"
            }
         },
         "patterns": [
            { "include": "#comment" },
            { "include": "#type_expression" }
         ],
         "end": "(?=\\s*\\))"
      },
      "interface_implementation": {
         "name": "entity.name.function support.function",
         "match": "\\b(function)\\s+(\\[(\\s*[A-Za-z0-9]+\\s*(\\<.*\\>)?\\s*\\.)+\\s*)[A-Za-z0-9]+(?=\\s*\\]\\s*(\\<.*\\>)?\\s*\\()",
         "captures": {
            "1": {
               "patterns": [
                  { "name": "keyword.control", "match": "[A-Za-z0-9]+" }
               ]
            },
            "2": {
               "patterns": [
                  {
                     "name": "entity.name.class support.class",
                     "match": "[A-Za-z0-9]+"
                  },
                  { "match": "\\." }
               ]
            }
         }
      },
      "function": {
         "begin": "(\\bfunction\\s+)",
         "beginCaptures": {
            "1": {
               "name": "keyword.control"
            }
         },
         "patterns": [
            {
               "begin": "(?<=function\\s+)",
               "contentName": "support.function entity.name.function",
               "end": "(?=[^[A-Za-z0-9]])"
            },
            { "include": "#generic_params" },
            { "include": "$self" }
         ],
         "end": "(?=\\))"
      },

      "inferred_model": {
         "name": "meta.class class entity.name.class",
         "match": "\\b((?<=\\bnew\\s+([A-Za-z0-9]+\\s*\\.)*\\s*)[A-Za-z0-9]+\\b)"
      },
      "inferred_function": {
         "name": "entity.name.function support.function",
         "match": "[A-Za-z0-9]+(?=\\s*(\\<.*\\>)?\\s*\\()",
         "captures": {
            "1": {
               "patterns": [{ "include": "#generic_args" }]
            }
         }
      },
      "import_punctuation": {
         "name": "punctuation.expression",
         "match": "\\{|\\}|\\,|\\."
      },
      "type_label": {
         "begin": "\\:\\s*",
         "patterns": [{ "include": "#type_expression" }],
         "end": "(,(?=\\s*([A-Za-z0-9]|_)+\\s*\\??\\s*(\\:|\\))))|(?=[^A-Za-z0-9\\&\\?\\_\\.\\<\\>\\,\\s\\(\\)\\[\\]])"
      },
      "discrete_type": {
         "patterns": [
            { "include": "#type_name" },
            { "include": "#generic_args" }
         ]
      },
      "type_name": {
         "name": "support.type entity.name.type",
         "match": "\\b[A-Za-z0-9_]+\\b"
      },
      "type_expression": {
         "patterns": [
            {
               "name": "punctuation",
               "match": "\\&"
            },
            {
               "name": "punctuation",
               "match": "\\[\\d*\\]"
            },
            {
               "name": "constant.language",
               "match": "\\s*This\\s*"
            },
            { "include": "#function_type" },
            {
               "patterns": [
                  { "include": "#discrete_type" },
                  { "match": "\\." },
                  {
                     "name": "punctuation",
                     "match": "\\|\\s*"
                  }
               ]
            }
         ]
      },
      "function_type": {
         "begin": "(\\bfn\\b)",
         "beginCaptures": {
            "1": {
               "name": "keyword.control"
            }
         },
         "patterns": [{ "include": "#generic_params" }, { "include": "$self" }],
         "end": "(?=\\))"
      },
      "generic_args": {
         "begin": "(?<=((implements\\s+|\\:\\s*)\\w+\\s*)\\<\\s*)",
         "patterns": [
            { "include": "#type_expression" },
            { "include": "#generic_args" }
         ],
         "end": "(?=\\>)"
      },
      "generic_params": {
         "begin": "(?<=((type|model|function|enum|interface)\\s*\\w+\\s*)\\<\\s*)",
         "patterns": [
            { "include": "#injunction" },
            {
               "name": "punctuation",
               "match": "\\&"
            },
            {
               "name": "punctuation",
               "match": "\\?"
            },
            {
               "name": "constant.language",
               "match": "\\bThis\\b"
            },
            { "include": "#type_name" },
            { "include": "#injunction" },
            { "include": "#type_label" },
            {
               "name": "punctuation",
               "match": "\\+"
            },
            { "include": "#punctuation_comma" }
         ],
         "end": "(?=\\>)"
      },

      "this": {
         "name": "constant.language",
         "match": "\\bthis\\b"
      },
      "identifier": {
         "patterns": [
            {
               "name": "entity variable",
               "match": "\\b[A-Za-z0-9]+(?=\\.)\\b"
            },
            {
               "name": "meta.definition.variable variable.other.constant",
               "match": "\\b[[:upper:][:digit:]_]+\\b"
            },
            {
               "name": "identifier meta.identifier variable.identifier",
               "match": "[A-Za-z0-9]+"
            }
         ]
      },
      "boolean_literal": {
         "name": "constant.language.literal",
         "match": "\\b(true|false)\\b"
      },

      "punctuation_comma": {
         "name": "punctuation.separator.comma.ts",
         "match": ","
      }
   },
   "scopeName": "source.wrl"
}
