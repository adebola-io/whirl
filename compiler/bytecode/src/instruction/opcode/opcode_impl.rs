
///! This module is auto generated.
use super::Opcode;

/// The formatting spacing between opcode and operands for the disassembler output.
pub const DISASSEMBLER_SPACING: usize = 20;


impl From<Opcode> for u8 {
    fn from(value: Opcode) -> Self {
        match value {
            Opcode::LoadInt8 => 0,
Opcode::LoadInt16 => 1,
Opcode::LoadFloat32 => 2,
Opcode::LoadFloat64 => 3,
Opcode::LoadBool => 4,
Opcode::LoadFunctionPtr => 5,
Opcode::MoveInt8 => 6,
Opcode::MoveInt16 => 7,
Opcode::MoveFloat32 => 8,
Opcode::MoveFloat64 => 9,
Opcode::MoveBool => 10,
Opcode::MoveAddr => 11,
Opcode::MoveEther => 12,
Opcode::StoreInt8 => 13,
Opcode::StoreInt16 => 14,
Opcode::StoreFloat32 => 15,
Opcode::StoreFloat64 => 16,
Opcode::StoreBool => 17,
Opcode::StoreFunctionPtr => 18,
Opcode::StoreAddr => 19,
Opcode::RetrieveInt8 => 20,
Opcode::RetrieveInt16 => 21,
Opcode::RetrieveFloat32 => 22,
Opcode::RetrieveFloat64 => 23,
Opcode::RetrieveBool => 24,
Opcode::RetrieveFunctionPtr => 25,
Opcode::RetrieveAddr => 26,
Opcode::ReturnInt8 => 27,
Opcode::ReturnInt16 => 28,
Opcode::ReturnFloat32 => 29,
Opcode::ReturnFloat64 => 30,
Opcode::ReturnBool => 31,
Opcode::ReturnFunctionPtr => 32,
Opcode::ReturnAddr => 33,
Opcode::ReturnEther => 34,
Opcode::Add => 35,
Opcode::Sub => 36,
Opcode::Mul => 37,
Opcode::Div => 38,
Opcode::Mod => 39,
Opcode::RightShift => 40,
Opcode::LeftShift => 41,
Opcode::EqInt8 => 42,
Opcode::EqInt16 => 43,
Opcode::EqFloat32 => 44,
Opcode::EqFloat64 => 45,
Opcode::EqBool => 46,
Opcode::EqFunctionPtr => 47,
Opcode::EqAddr => 48,
Opcode::Negate => 49,
Opcode::JumpIfTrue => 50,
Opcode::JumpConditional => 51,
Opcode::LoopFor => 52,
Opcode::Stall => 53,
Opcode::BreakLoop => 54,
Opcode::Goto => 55,
Opcode::Call => 56,
Opcode::Return => 57,
Opcode::NewInstanceValueA => 58,
Opcode::StoreValueAToFrame => 59,
Opcode::NewInstanceValueB => 60,
Opcode::NewArrayAddrA => 61,
Opcode::NewArrayAddrE => 62,
Opcode::GetPropertyOffset => 63,
Opcode::MoveValtoRet => 64,
Opcode::SpawnSeq => 65,
Opcode::SyncSeq => 66,
Opcode::HaltSeq => 67,
Opcode::Invoke => 68,
Opcode::Exit => 69,

        }
    }
}



impl From<u8> for Opcode {
    fn from(value: u8) -> Self {
        match value {
            0 => Self::LoadInt8,
1 => Self::LoadInt16,
2 => Self::LoadFloat32,
3 => Self::LoadFloat64,
4 => Self::LoadBool,
5 => Self::LoadFunctionPtr,
6 => Self::MoveInt8,
7 => Self::MoveInt16,
8 => Self::MoveFloat32,
9 => Self::MoveFloat64,
10 => Self::MoveBool,
11 => Self::MoveAddr,
12 => Self::MoveEther,
13 => Self::StoreInt8,
14 => Self::StoreInt16,
15 => Self::StoreFloat32,
16 => Self::StoreFloat64,
17 => Self::StoreBool,
18 => Self::StoreFunctionPtr,
19 => Self::StoreAddr,
20 => Self::RetrieveInt8,
21 => Self::RetrieveInt16,
22 => Self::RetrieveFloat32,
23 => Self::RetrieveFloat64,
24 => Self::RetrieveBool,
25 => Self::RetrieveFunctionPtr,
26 => Self::RetrieveAddr,
27 => Self::ReturnInt8,
28 => Self::ReturnInt16,
29 => Self::ReturnFloat32,
30 => Self::ReturnFloat64,
31 => Self::ReturnBool,
32 => Self::ReturnFunctionPtr,
33 => Self::ReturnAddr,
34 => Self::ReturnEther,
35 => Self::Add,
36 => Self::Sub,
37 => Self::Mul,
38 => Self::Div,
39 => Self::Mod,
40 => Self::RightShift,
41 => Self::LeftShift,
42 => Self::EqInt8,
43 => Self::EqInt16,
44 => Self::EqFloat32,
45 => Self::EqFloat64,
46 => Self::EqBool,
47 => Self::EqFunctionPtr,
48 => Self::EqAddr,
49 => Self::Negate,
50 => Self::JumpIfTrue,
51 => Self::JumpConditional,
52 => Self::LoopFor,
53 => Self::Stall,
54 => Self::BreakLoop,
55 => Self::Goto,
56 => Self::Call,
57 => Self::Return,
58 => Self::NewInstanceValueA,
59 => Self::StoreValueAToFrame,
60 => Self::NewInstanceValueB,
61 => Self::NewArrayAddrA,
62 => Self::NewArrayAddrE,
63 => Self::GetPropertyOffset,
64 => Self::MoveValtoRet,
65 => Self::SpawnSeq,
66 => Self::SyncSeq,
67 => Self::HaltSeq,
68 => Self::Invoke,
69 => Self::Exit,

            _ => panic!("Undefined opcode conversion. No opcode maps to value {value}.")
        }
    }
}

