module Maybe;

use Internals.{ IsNull, Nullptr, Flow };
use Core.{
    Prelude.{
        Outcome.{ Ok, Err, },
        Traits.{ Guaranteed, Try }
    },
    Process.{ PanicOnCaller, Error },
    Bool
};

/// Creates a `Maybe` with no value.
public function None<T>(): Maybe<T> {
    new Maybe(Nullptr)
}

/// Creates a `Maybe` with an internal value.
public function Some<T>(value: T): Maybe<T> {
    new Maybe(value)
}

// /// A value that may or may not exist.
public model Maybe<T> implements Guaranteed<T> + Try<T> {
    var value: T;

    new(value: T) {
        this.value = value;
    }
    // /// Implementation of `Guarantee` trait.
    // public function [Guaranteed.Guarantee](): T {
    //     this.Unwrap()
    // }
    // /// Implementation of `Try` trait.
    // public function [Try.Try]<U>(): Result<Flow<T>, Flow<Maybe<U>>> {
    //     if this.IsSome() { 
    //         Ok(Flow.Normal(this.value)) 
    //     } 
    //     else Err(Flow.Return(None()))
    // }
    /// Returns a Bool indicating if the Maybe contains no value.
    /// ### Usage
    /// ```
    /// noValue: Maybe<String> := None();
    /// AssertThat(noValue.IsNone());
    /// 
    /// stringValue := Some("boy");
    /// AssertThat(!stringValue.IsNone());
    /// ```
    public function IsNone(): Bool {
        IsNull(this.value)
    }
    /// Returns a Bool indicating whether there is a value contained or not.
    public function IsSome(): Bool {
        !IsNull(this.value)
    }
    /// Ignores the maybe and returns the internal value. 
    /// It will throw an error if no value is present.
    /// ### Usage
    /// ```
    /// numValue := Some(89);
    /// Assert(numValue.Unwrap()).Equals(89);
    /// 
    /// noValue: Maybe<Number> = None();
    /// noValue.Unwrap(); // Will panic with an error.
    /// ```
    /// ### Panics
    /// It panics if called on a `Maybe` with no value.
    public function Unwrap(): T {
        if this.IsNone() {
            PanicOnCaller(new Error("Called Unwrap on a None Value"))
        } else { 
            this.value 
        }
    }
    /// Returns the internal value, or another given value.
    public function UnwrapOr(value: T): T {
        if this.IsNone() { value } else { this.value }
    }
    /// Converts a `Maybe<T>` to a `Maybe<E>` by applying a function.
    public function Map<U>(func: fn(former: T): U): Maybe<U> {
        Some(func(this?))
    }   
}
