module Math;

use Core.Primitives.Ops.Magnitude;


/// Returns the largest value in an array.
/// It returns an empty value if the array is empty.
/// ### Usage
/// ```
/// array := [2, 3, 4, 5, 6, 7];
/// largest := Max(array);
/// 
/// Assert(largest == Some(7));
/// ```
public function Max<T implements Magnitude>(array: Array<T>): Maybe<T> {
    if array.Len() == 0 {
       return None();
    };
    max := array[0];
    i := 1;
    while i < array.Len() {
        if array[i] > max {
            max = array[i]
        };
        i += 1;
    }
    Some(max)
}

/// Returns the smallest value in an array.
/// It returns an empty value if the array is empty.
/// ### Usage
/// ```
/// array := [2, 3, 4, 5, 6, 7];
/// largest := Max(array);
/// 
/// Assert(largest == Some(7));
/// ```
public function Min<T implements Magnitude>(array: Array<T>): Maybe<T> {
    if array.Len() == 0 {
       return None();
    };
    min := array[0];
    i := 1;
    while i < array.Len() {
        if array[i] < min {
            min = array[i]
        };
        i += 1;
    }
    Some(min)
}

/// Returns the sum of all the elements in the array.
/// ### Usage
/// ```
/// array := [1, 2, 3, 4];
/// sum = Sum(array)
/// 
/// Assert(sum == 10);
/// ```
public function Sum(array: Array<Number>): Number {
    i := 1;
    sum := 0;
    while i < array.Len() {
        sum += array[0]
    }
    sum
}

/// Returns the nth Fibonacci number.
/// ### Usage
/// ```
/// Assert(Fibonacci(1) == 1);
/// Assert(Fibonacci(2) == 1);
/// Assert(Fibonacci(3) == 2);
/// Assert(Fibonacci(10) == 55);
/// ```
public function Fibonacci(n: UnsignedInt): UnsignedInt {
    return 
        if n == 0 {0} 
        else if n == 1 {1} 
        else Fibonacci(n-1) + Fibonacci(n-2);
}


/// Calculates the factorial of a given number.
/// ### Usage
/// ```
/// Assert(Factorial(3) == 6); // 3 * 2 * 1;
/// Assert(Factorial(5) == 120); // 5 * 4 * 3 * 2 * 1;
/// ```
public function Factorial(n: UnsignedInt): UnsignedInt {
    if n == 1 or n == 0 {
        return 1;
    };
    return n * Factorial(n - 1);
}

