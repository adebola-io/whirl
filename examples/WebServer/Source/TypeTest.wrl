module TypeTest;

test "Testing types." {
    use Core.Testing.Assert;
    use Core.Collections.Tuple;

    /// Returns the value itself.
    function Identity<T>(value: T): T {
        return value;
    }
    /// Swaps the elements of a tuple.
    function Swap<T, U>(tuple: Tuple<T, U>): Tuple<U, T> {
        tuple.Swap()
    }
    // swapping variables.
    tuple := new Tuple(true, "hello");
    swapped := tuple.Swap();
    Assert(tuple.Swap()).Equals(swapped);
    Assert(Swap(tuple)).Equals(tuple.Swap());

    // Coercion.
    stringItself := Identity("String"); // Should have type String.
    maybe := Err(true);
    maybe = Ok(None());
    maybe = Ok(Some("hello, world"));
    // maybe should have type Outcome<Maybe<String>, Bool>;

    // Opaque types.
    model Football {
        new(){}
        /// Bounce for a football.
        public function Bounce(): String {
            return "Football is bouncing...";
        }
    }
    model Tennisball {
        new(){}
        /// Bounce for a tennisball.
        public function Bounce() : String {
            return "Tennisball is bouncing...";
        }
    }
    model Basketball {
        new(){}
        /// Bounce for a basketball.
        public function Bounce(): String {
            return "Basketball is bouncing...";
        }
    }
    type Ball = Football | Tennisball | Basketball;
    ball: Ball := new Football();
    ball.Bounce();
    ball = new Basketball();
    ball.Bounce();

    trait Bounceable {
        public function Bounce(): String;
    }
    function Nested<T implements Bounceable>(newBall: T) {
        type InnerBall = T | Ball;
        ball: InnerBall := new Football();
        ball.Bounce();
        ball = newBall;
        ball.Bounce();
    }

    // Opaque types with traits.
    trait TransformableTo<T> {
        public function Transform(): T;
    }
    model Box<T> implements TransformableTo<T> {
        new(value: T){}
        public function [TransformableTo.Transform](): T {
            Todo()
        }
    }
    model Sphere<T> implements TransformableTo<T> {
        new(value: T){}
        public function [TransformableTo.Transform](): T {
            Todo()
        }
    }
    type Transformable<T> = Box<T> | Sphere<T>;
    entity: Transformable<Transformable<String>> := new Box(new Sphere("hello"));

    // Numeric types.
    number := 90;
    number = 12;
    array := [1, 2, 3, 4, number];

    // function type coercion.
    strArray := ["hello", "world"];
    strArrayHasHello := strArray.Iter().Any(fn(element) element == "hello");
    functor: fn(): fn(value: String): String := fn() fn(value) value.ToStr();

    // Auto inferred generics.
    arr := [];
    arr = ["Hello", "world"]; // arr should infer type Array<String>
    firstItem := arr[0]; // Should infer type string.
    arr2 := [];
    arr2.Push(Some(true)); // arr2 should infer type Array<Maybe<Bool>>.
    arr3 := [];
    num: Number := 99;
    arr3[0] = num; // arr3 should infer type Array<Number>

    // Destructuring.
    model Person implements Default {
        public var name: String;
        public var age: UInt8; // Set automatically.
        new(name: String, age?: UInt8) {
            this.name = name;
            this.age = Maybe.UnwrapOrDefault(age);
        }
        public static function [Default.Init](): This {
            return new Person("{unknown}");
        }
    }
    var person: Person; // possible because Person implements Default.
    var { name, age }: Person;
    var { name as johnsName} = new Person("John Doe");

    function AnyType<T>(value: T) {}
}