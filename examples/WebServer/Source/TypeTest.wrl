module TypeTest;

use Core.Primitives.Ops.Addition;
use Core.Collections.{Tuple, Quadruple};
use Core.Testing.Assert;


/// Returns the value itself.
public function Identity<T>(value: T): T {
    value
}

/// Takes in a tuple of values and returns a tuple with the values swapped.
public function Swap<T, U>(tuple: Tuple<T, U>): Tuple<U, T> {
    tuple.Swap()
}

/// Finds an item within an array.
public function Find<T>(value: Array<T>, predicate: fn(value: &T): Bool): Maybe<T> {
    i := 0;
    while i < value.Len() {
        item := &value[i];
        if predicate(item) {
            return Some(item);
        }
    }
    return None();
}

/// Transforms an array by applying a defined function on each of its elements.
public function Map<T, U>(value: Array<T>, predicate: fn(value: T): U): Array<U> {
    i := 0;
    newArray := [];
    while i < value.Len() {
        item := value[i];
        newValue := predicate(item);
        newArray.push(newValue);
    }
    newArray
}


function Main () {
    identity: String := Identity("Hello");
    maybeString: Maybe<String> := Some(identity);

    array := ["hello", "from", "the", "other", "side"];
    str := Find(array, fn(value) true).Unwrap().Chars().Next().Unwrap();

    array2 := [1, 2, 3, 4, 5, 6, 7, 8];
    arrayStringified := Map(array2, fn(value) "string");

    tuple := new Tuple(true, ["Hello there..."]);
    swappedTuple := tuple.Swap();

    quadruple := new Quadruple("Hello there", true, Some("string"), [true]);
    tuplified := quadruple.ToTuple().second.Swap().first[0];

     
    quadruple2 := new Quadruple(Some(true), "Sefunmi", true, [false]);
    split := quadruple2.ToTuple();
    
    Assert(split.first).Equals(new Tuple(Some(true), "Sefunmi"));
    Assert(split.second.Swap()).Equals(new Tuple([false], true));
}