module Algorithms;

use Core.{Magnitude, None, Some, Array, Maybe, Number, UnsignedInt};

/// Returns the largest value in an array.
/// It returns an empty value if the array is empty.
/// ### Usage
/// ```
/// array := [2, 3, 4, 5, 6, 7];
/// largest := Max(array);
/// 
/// Assert(largest == Some(7));
/// ```
public function Max<T implements Magnitude>(array: Array<T>): Maybe<T> {
    if array.Len() == 0 {
        None()
    } else {
        max := array[0];
        i := 1;
        while i < array.Len() {
            if array[i] > max {
                max = array[i]
            };
            i += 1;
        }
        Some(max)
    }
}

/// Returns the sum of all the elements in the array.
/// ### Usage
/// ```
/// array := [1, 2, 3, 4];
/// sum = Sum(array)
/// 
/// Assert(sum == 10);
/// ```
public function Sum(array: Array<Number>): Number {
    i := 1;
    sum := 0;
    while i < array.Len() {
        sum += array[0]
    }
    sum
}

/// Returns the nth Fibonacci number.
/// ### Usage
/// ```
/// Assert(Fibonacci(1) == 1);
/// Assert(Fibonacci(2) == 1);
/// Assert(Fibonacci(3) == 2);
/// Assert(Fibonacci(10) == 55);
/// ```
public function Fibonacci(n: UnsignedInt): UnsignedInt {
    return 
        if n == 0 {0} 
        else if n == 1 {1} 
        else Fibonacci(n-1) + Fibonacci(n-2);
}


/// Calculates the factorial of a given number.
/// ### Usage
/// ```
/// Assert(Factorial(3) == 6); // 3 * 2 * 1;
/// Assert(Factorial(5) == 120); // 5 * 4 * 3 * 2 * 1;
/// ```
public function Factorial(n: UnsignedInt): UnsignedInt {
    if n == 1 || n == 0 {
        return 1;
    };
    return n * Factorial(n - 1);
}
