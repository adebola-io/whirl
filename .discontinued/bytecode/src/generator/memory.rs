use std::collections::{HashMap, VecDeque};

use analyzer::{EvaluatedType, SymbolIndex, SymbolLibrary};
use ast::BinOperator;

use crate::{CallablePtrId, Opcode, MAX_REGISTER_COUNT, PAD};

/// Responsible for aportioning and managing registers and memory during code generation,
/// and storing the generated code.
/// It allows me to operate on the expression nodes with the lower level details of register
/// allocation and reuse abstracted out.
pub struct BytecodeMemoryManager {
    /// The generated bytecode.
    pub code: Vec<u8>,
    /// A shadow stack of frames for storing and retrieving variables.
    frame_stack: Vec<BytecodeCallFrame>,
    /// The attributor stores property offsets in linear form before they can be moved to
    /// the Addr registers.
    /// For example, for a type:
    /// ```wrl
    /// type Data {
    ///     var age: UInt8;
    ///     var name: String;
    /// }
    /// type Person {
    ///     var data: Data;
    /// }
    /// ```
    /// person.data would have an attribution value of (stackAddress, [0]), The first value
    /// in the `person` instance, then person.data.age would have the attribution value of
    /// (stackAddress, [0, 0]), the first value in the first value of the person instance.
    attributor: Option<(StackAddress, Vec<u32>)>,
}

#[derive(Debug)]
/// A representation of the registers in the virtual machine for easy memory management.
pub struct Register {
    id: RegisterId,
    state: RegisterState,
}

/// Identifier marking a register.
#[derive(Debug, Clone, Copy)]
pub struct RegisterId(pub u8, pub RegisterGroup);

/// The index of a variable on the current stack frame.
#[derive(Debug, Clone, Copy)]
pub struct StackAddress(pub u32);

pub struct BytecodeCallFrame {
    /// Each group corresponds to a data type in the runtime.
    /// The possible data types are:
    /// - Int8
    /// - Int16
    /// - Float32
    /// - Float64
    /// - Address of a value on the heap.
    /// - Index of a constant.
    /// Each group has a maximum of 255 registers to track
    /// a sufficient number of live expressions in each function.
    register_groups: HashMap<RegisterGroup, Vec<Register>>,
    /// The address of stack values in the program.
    addresses: HashMap<SymbolIndex, StackAddress>,
}

#[derive(Debug, Eq, PartialEq, Hash, Clone, Copy)]
pub enum RegisterGroup {
    /// For storing UInt8 values.
    Int8,
    /// For storing UInt64 values.
    Int16,
    /// For storing Float32 values.
    F32,
    /// For storing Float64 values.
    F64,
    /// For storing boolean values.
    Bool,
    /// For storing callable pointers.
    FunctionPtr,
    /// For storing references to instances of models, enum and opaque values.
    Addr,
    /// The set of registers storing "never" values.
    Ether,
}
impl RegisterGroup {
    /// Returns the register group that is distinct to an inferred type,
    /// according to the symbol library.
    pub fn of(inferred_type: &EvaluatedType, symbollib: &SymbolLibrary) -> RegisterGroup {
        match inferred_type {
            EvaluatedType::ModelInstance {
                type,
                is_invariant,
                generic_arguments,
            } => match type {
                // _ if type == &symbollib.uint8.unwrap() => RegisterGroup::Int8,
                // _ if type == &symbollib.uint16.unwrap() => RegisterGroup::Int16,
                // _ if type == &symbollib.uint32.unwrap() => RegisterGroup::F32,
                // _ if type == &symbollib.uint64.unwrap() => RegisterGroup::F64,
                // _ if type == &symbollib.float32.unwrap() => RegisterGroup::F32,
                // _ if type == &symbollib.float64.unwrap() => RegisterGroup::F64,
                _ if type == &symbollib.bool.unwrap() => RegisterGroup::Bool,
                _ => todo!(),
            },
            EvaluatedType::OpaqueTypeInstance {
                available_methods,
                available_interfaces,
                aliased_as,
                collaborators,
                generic_arguments,
            } => match aliased_as.unwrap() {
                // symbol if symbol == symbollib.uint.unwrap() => RegisterGroup::F64,
                // symbol if symbol == symbollib.int.unwrap() => RegisterGroup::F64,
                // symbol if symbol == symbollib.float.unwrap() => RegisterGroup::F64,
                _ => todo!(),
            },
            _ => unreachable!(
                "Bytecode gen failed. Cannot determine group for type {:?}",
                symbollib.format_evaluated_type(inferred_type)
            ),
        }
    }
    /// Returns byte representation of the register group.
    pub fn as_byte(&self) -> u8 {
        match self {
            RegisterGroup::Int8 => 0,
            RegisterGroup::Int16 => 1,
            RegisterGroup::F32 => 2,
            RegisterGroup::F64 => 3,
            RegisterGroup::Bool => 4,
            RegisterGroup::FunctionPtr => 5,
            RegisterGroup::Addr => 6,
            RegisterGroup::Ether => 7,
        }
    }
    /// Creates a register group from a byte representation.
    pub fn from_byte(value: u8) -> Self {
        match value {
            0 => Self::Int8,
            1 => Self::Int16,
            2 => Self::F32,
            3 => Self::F64,
            4 => Self::Bool,
            5 => Self::FunctionPtr,
            _ => panic!("Unsupported conversion from byte to register group!"),
        }
    }
}

#[derive(Debug, Default)]
/// Current state of the register in relation to the flow of control in the program.
pub enum RegisterState {
    #[default]
    Empty,
    Occupied,
}

impl BytecodeMemoryManager {
    /// Creates a new bytecode memory manager.
    pub fn new() -> Self {
        Self {
            code: vec![PAD],
            frame_stack: vec![BytecodeCallFrame::new()],
            attributor: None,
        }
    }
    /// Returns the address of a value currently stored on the frame.
    pub fn get_address_of(&self, value: SymbolIndex) -> StackAddress {
        todo!()
    }
    /// Stores a value in the stack frame.
    pub fn store_variable(&self, value: SymbolIndex) -> StackAddress {
        todo!()
    }
    /// Load an immediate numeric value into a register.
    /// It returns the id of whatever register was loaded.
    pub fn load_immediate_number(
        &mut self,
        group: RegisterGroup,
        value: &ast::Number,
    ) -> RegisterId {
        let mut register = self.get_free_register(group);
        if register.is_none() {
            register = Some(self.create_register(group));
        }
        let register = register.unwrap();
        register.state = RegisterState::Occupied;
        let id = register.id;
        let number = match value {
            ast::Number::Binary(data)
            | ast::Number::Octal(data)
            | ast::Number::Hexadecimal(data)
            | ast::Number::Decimal(data) => data
                .parse::<f64>()
                .expect("Bytecode gen failed due to numeric conversion error."),
            ast::Number::None => unreachable!(),
        };
        // code gen.
        let base_opcode = match group {
            RegisterGroup::Int8 => Opcode::LoadInt8,
            RegisterGroup::Int16 => Opcode::LoadInt16,
            RegisterGroup::F32 => Opcode::LoadFloat32,
            RegisterGroup::F64 => Opcode::LoadFloat64,
            _ => unreachable!(
                "Bytecode generation failed. Cannot load number value into invalid register."
            ),
        };
        self.code.push(base_opcode.into());
        self.code.push(id.0);
        match group {
            RegisterGroup::Int8 => self.code.push(number as u8),
            RegisterGroup::Int16 => (number as u16)
                .to_be_bytes()
                .into_iter()
                .for_each(|byte| self.code.push(byte)),
            RegisterGroup::F32 => (number as f32)
                .to_be_bytes()
                .into_iter()
                .for_each(|byte| self.code.push(byte)),
            RegisterGroup::F64 => (number as f64)
                .to_be_bytes()
                .into_iter()
                .for_each(|byte| self.code.push(byte)),
            _ => {}
        };
        return id;
    }

    /// Creates a new register in a group.
    ///
    /// It panics if the group is already full.
    pub fn create_register(&mut self, group: RegisterGroup) -> &mut Register {
        let frame = self.frame_stack.len() - 1;
        let registers = self
            .frame_stack
            .last_mut()
            .expect("No frame in memory.")
            .register_groups
            .get_mut(&group)
            .unwrap();
        let len = registers.len();
        if len == MAX_REGISTER_COUNT as usize {
            panic!("Register allocation failed. Maximum register count for free values exceeded.");
        }
        let id = RegisterId(len as u8, group);
        let new_register = Register {
            id,
            state: RegisterState::Empty,
        };
        registers.push(new_register);
        registers.last_mut().unwrap()
    }

    /// Returns a mutable reference to a free register from the register pool, if it exists.
    pub fn get_free_register(&mut self, group: RegisterGroup) -> Option<&mut Register> {
        let registers = self
            .frame_stack
            .last_mut()
            .expect("No frame in memory.")
            .register_groups
            .get_mut(&group)
            .unwrap();
        registers.iter_mut().find(|register| {
            if register.state.is_empty() {
                // println!(
                //     "reusing existing register %r{} in group {:?}",
                //     register.id.0, register.id.1
                // );
                return true;
            }
            return false;
        })
    }

    /// Load an immediate boolean value into a register.
    /// Returns the id of the loaded register.
    pub fn load_immediate_boolean(&mut self, value: bool) -> RegisterId {
        let mut register = self.get_free_register(RegisterGroup::Bool);
        if register.is_none() {
            register = Some(self.create_register(RegisterGroup::Bool));
        }
        let register = register.unwrap();
        register.state = RegisterState::Occupied;
        let id = register.id;

        // code gen.
        self.code.push(Opcode::LoadBool.into());
        self.code.push(if value { 1 } else { 0 });
        return id;
    }

    /// Loads a value into a functionptr register.
    /// Returns the id of the loaded register.
    pub fn load_immediate_function_ptr(&mut self, value: CallablePtrId) -> RegisterId {
        let mut register = self.get_free_register(RegisterGroup::FunctionPtr);
        if register.is_none() {
            register = Some(self.create_register(RegisterGroup::FunctionPtr));
        }
        let register = register.unwrap();
        register.state = RegisterState::Occupied;
        let id = register.id;

        // code gen.
        self.code.push(Opcode::LoadFunctionPtr.into());
        self.code.push(id.0);
        value
            .0
            .to_be_bytes()
            .into_iter()
            .for_each(|byte| self.code.push(byte));
        return id;
    }
    /// Generates the code to call a function in a given function register id.
    pub fn call_function_in(&mut self, register_id: RegisterId) {
        let register = self.get_register_mut(register_id);
        register.state.clear();

        // code gen.
        self.code.push(Opcode::Call.into());
        self.code.push(register_id.0);
    }
    /// Generate bytecode to move the value in a register of a
    /// register group to a stack address.
    pub fn store(&mut self, from: RegisterId, to: StackAddress) {
        let register = self.get_register_mut(from);
        register.state.clear();
        // code gen.
        let base_opcode = match from.1 {
            RegisterGroup::Int8 => Opcode::StoreInt8,
            RegisterGroup::Int16 => Opcode::StoreInt16,
            RegisterGroup::F32 => Opcode::StoreFloat32,
            RegisterGroup::F64 => Opcode::StoreFloat64,
            RegisterGroup::Bool => Opcode::StoreBool,
            RegisterGroup::FunctionPtr => Opcode::StoreFunctionPtr,
            RegisterGroup::Addr => Opcode::StoreAddr,
            RegisterGroup::Ether => panic!("Ether value must be moved to addr register first."),
        };
        let stack_address = to.0.to_be_bytes();
        self.code.push(base_opcode.into());
        stack_address
            .into_iter()
            .for_each(|byte| self.code.push(byte));
        self.code.push(from.0);
    }
    /// Generates bytecode to retrieve a value in a stack address to a register.
    ///
    /// It returns the id of the register where the value was stored.
    pub fn retrieve(&mut self, from: StackAddress, group: RegisterGroup) -> RegisterId {
        let mut register = self.get_free_register(group);
        if register.is_none() {
            register = Some(self.create_register(group));
        }
        let register = register.unwrap();
        register.state = RegisterState::Occupied;
        let id = register.id;

        // code gen.
        let base_opcode = match group {
            RegisterGroup::Int8 => Opcode::RetrieveInt8,
            RegisterGroup::Int16 => Opcode::RetrieveInt16,
            RegisterGroup::F32 => Opcode::RetrieveFloat32,
            RegisterGroup::F64 => Opcode::RetrieveFloat64,
            RegisterGroup::Bool => Opcode::RetrieveBool,
            RegisterGroup::FunctionPtr => Opcode::RetrieveFunctionPtr,
            RegisterGroup::Addr => Opcode::RetrieveAddr,
            _ => unreachable!("Cannot retrieve into an abstract register."),
        };
        self.code.push(id.0); // destination register.
        let stack_address = from.0.to_be_bytes();
        stack_address
            .into_iter()
            .for_each(|byte| self.code.push(byte)); // source address.
        return id;
    }

    /// Returns a particular register. It will panic if the register does not exist.
    pub fn get_register_mut(&mut self, from: RegisterId) -> &mut Register {
        &mut self
            .frame_stack
            .last_mut()
            .unwrap()
            .register_groups
            .get_mut(&from.1)
            .expect("Could not find group for data type")[from.0 as usize]
    }

    /// Clears the state of a register
    pub fn clear_register(&mut self, register: RegisterId) {
        let register = self.get_register_mut(register);
        register.state = RegisterState::Empty;
    }

    /// Opens a new frame on the stack.
    pub fn create_new_frame(&mut self) {
        self.frame_stack.push(BytecodeCallFrame::new());
    }

    /// Clears the current frame on the stack.
    pub fn clear_frame(&mut self) {
        self.frame_stack.pop();
    }

    /// Generates the code to move the value in the global return register
    /// into the register of a given type and returns the register id of the value.
    pub fn get_return_value(&mut self, group: RegisterGroup) -> RegisterId {
        let mut new_register = self.get_free_register(group);
        if new_register.is_none() {
            new_register = Some(self.create_register(group));
        }
        let new_register = new_register.unwrap();
        new_register.state = RegisterState::Occupied;
        let id = new_register.id;

        // code gen.
        self.code.push(Opcode::MovRetVal.into());
        self.code.push(group.as_byte());
        self.code.push(id.0);

        return id;
    }

    /// Move a value from an ether register to a type-specific register.
    pub fn typecast_ether(&mut self, from: RegisterId, to: RegisterGroup) -> RegisterId {
        let register = self.get_register_mut(from);
        register.state = RegisterState::Empty;

        let id = self.get_free_or_create_register(to);
        self.get_register_mut(id).state = RegisterState::Occupied;

        // code gen.
        self.code.push(Opcode::MoveEther.into());
        let register_group = to.as_byte();
        self.code.push(register_group);
        self.code.push(id.0);
        self.code.push(from.0);
        return id;
    }

    fn get_free_or_create_register(&mut self, to: RegisterGroup) -> RegisterId {
        let mut new_location = self.get_free_register(to);
        if new_location.is_none() {
            new_location = Some(self.create_register(to));
        }
        let new_location = new_location.unwrap();
        let id = new_location.id;
        id
    }

    /// Generates code that takes two registers, performs a binary operation and
    /// returns the rgister that contains the result.
    pub fn condense_into_one(
        &mut self,
        left_register: RegisterId,
        right_register: RegisterId,
        operator: BinOperator,
    ) -> RegisterId {
        assert_eq!(left_register.1, right_register.1);
        // Empty both registers.
        let lregister = self.get_register_mut(left_register);
        lregister.state.clear();
        let rregister = self.get_register_mut(right_register);
        rregister.state.clear();

        let result_register_id = self.get_free_or_create_register(left_register.1);
        self.get_register_mut(result_register_id).state = RegisterState::Occupied;

        // code-gen
        let base_opcode = match operator {
            BinOperator::Multiply => Opcode::Mul,
            BinOperator::Divide => Opcode::Div,
            BinOperator::PowerOf => todo!(),
            BinOperator::BitAnd => todo!(),
            BinOperator::BitOr => todo!(),
            BinOperator::Equals => todo!(),
            BinOperator::NotEquals => todo!(),
            BinOperator::Remainder => todo!(),
            BinOperator::Add => Opcode::Add,
            BinOperator::Subtract => Opcode::Sub,
            BinOperator::Range => todo!(),
            BinOperator::LessThan => todo!(),
            BinOperator::GreaterThan => todo!(),
            BinOperator::LessThanOrEquals => todo!(),
            BinOperator::GreaterThanOrEquals => todo!(),
            BinOperator::LeftShift => todo!(),
            BinOperator::RightShift => todo!(),
        };
        self.code.push(base_opcode.into());
        let group = left_register.1.as_byte();
        self.code.push(group);
        self.code.push(result_register_id.0);
        self.code.push(left_register.0);
        self.code.push(right_register.0);

        return result_register_id;
    }

    /// Generates code to move the value in a register to the global return
    /// register.
    ///
    /// The global return register only stores numeric values as f64, so it can
    /// allow easy up and downscaling conversions between numeric types.
    pub fn move_to_return_register(&mut self, register_id: RegisterId) {
        let register = self.get_register_mut(register_id);
        register.state.clear();

        // code-gen
        self.code.push(Opcode::MoveToRet.into());
        self.code.push(register_id.1.as_byte());
        self.code.push(register_id.0);
    }
}

impl BytecodeCallFrame {
    pub fn new() -> Self {
        let mut register_groups = HashMap::new();
        for group in [
            RegisterGroup::Addr,
            RegisterGroup::Bool,
            RegisterGroup::Ether,
            RegisterGroup::F32,
            RegisterGroup::F64,
            RegisterGroup::F64,
            RegisterGroup::FunctionPtr,
            RegisterGroup::Int16,
            RegisterGroup::Int8,
        ] {
            register_groups.insert(group, Vec::with_capacity(255));
        }
        Self {
            register_groups,
            addresses: HashMap::new(),
        }
    }
}

impl RegisterState {
    /// Returns `true` if the bytecode register state is [`Empty`].
    ///
    /// [`Empty`]: BytecodeRegisterState::Empty
    #[must_use]
    pub fn is_empty(&self) -> bool {
        matches!(self, Self::Empty)
    }

    /// Returns `true` if the bytecode register state is [`Occupied`].
    ///
    /// [`Occupied`]: BytecodeRegisterState::Occupied
    #[must_use]
    pub fn is_occupied(&self) -> bool {
        matches!(self, Self::Occupied)
    }
    /// Empties the register state.
    fn clear(&mut self) {
        *self = Self::Empty
    }
}
