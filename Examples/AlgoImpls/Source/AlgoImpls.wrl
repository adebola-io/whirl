module Main;

/// A last-in first-out data structure.
public model Stack<T> {
    var items: ArrayOf<T>;
    var capacity: Int;

    new(capacity?: Int) {
        this.items = [];
        this.capacity = capacity.UnwrapOr(Core.Math.INFINITY);
    }

    /// Dynamically change the number of items in the stack.
    ///
    /// If there are currently more items that the new capacity, then the stack will be truncated.
    /// ## Usage
    /// ```wrl
    /// use Structures.Stack;
    /// stack: Stack<Int> := new Stack();
    ///
    /// Assert(stack.Capacity() == 0);
    /// stack.SetCapacity(1); // Sets the stack to contain only one item.
    /// 
    /// stack.Push(10).Unwrap();
    /// Assert(stack.Push(11).IsErr()); // Cannot push since the stack is full.
    ///
    /// // Increasing the capacity.
    /// stack = new Stack();
    /// stack.SetCapacity(10);
    /// for item in 0..9 {
    ///     stack.Push(item).Unwrap();   
    /// }
    /// Assert(stack.Push(99).IsErr())
    /// stack.SetCapacity(11);
    /// Assert(stack.Push(99).IsOk());
    /// 
    /// // Reducing the capacity
    /// stack.setCapacity(2); // Shrinks the stack to only two items.
    /// Assert(stack.Size() == 2);
    /// ```
    public function SetCapacity(value: Int) {
        while value < this.items.Length() {
            this.items.Pop();
        }
        this.capacity = value;
    }

    /// Returns the top value in the stack without removing it.
    public function Top(): Maybe<T> {
        this.items.Last()
    }

    /// Removes the last item from the stack and returns it, if it exists.
    public function Pop(): Maybe<T> {
        this.items.Pop()
    }

    /// Enter data into the stack.
    ///
    /// This method will fail if the size of the stack is already at maximum length.
    public function Push(data: T): Outcome<_, StackError> {
        if this.items.Length() == this.capacity {
            Err(new StackError("The stack is already full."))
        } else {
            this.items.Push(data);
            Ok(_)
        }
    }

    /// Returns the capacity of the stack.
    public function Capacity(): Int {
        this.capacity
    }

    /// Returns the size of the stack.
    public function Size(): Int {
        this.items.Length()
    }
}



use Core.Testing.Assert;

test "It tests stack pushing and popping" {
    stack: Stack<Int> := new Stack();
    Assert(stack.Size() == 0);

    stack.Push(8);
    stack.Push(18);

    Assert(stack.Size() == 2);
}

public type UnsignedInt = U8Int | U16Int | U32Int;
public type Int = UnsignedInt | SignedInt;
public type Float = Float32 | Float64;
public type Number = SignedInt | Float | BigInt;


public trait PartialEquality {
    function Equals(other: This): Bool;
}
public trait Rangeable {
    function To(other: This): RangeOver<This>;
}
public trait PartialOrdering {
    function Max(other: This): This; 
}
public trait IndexWith<T, U> {
    function Access(accessor: T): U;
}
public trait Addition {
    function Add(other: This): This;
}
public trait Subtraction {
    function Subtract(other: This): This;
}
public trait Multiplication {
    function Multiply(other: This): This;
}
public trait Division {
    function Divide(other: This): This;
}
public trait Display {
    function ToString(): String;
}
/// This allows you to declare variables without initializing them.
public trait Default {
    function Default(): This;
}

