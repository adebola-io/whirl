// !::no-prelude::!
module String;

use Integer.Integer;
use Boolean.Boolean;
use Iteratable.Iteratable;
use Maybe.Maybe; 
use Package.{Internals.{Invoke, Invocation}, Memory.CharSpace, Ops.Addition};
use Range.Range;
use UnsignedInteger.UnsignedInteger; 

/// Model for creating, manipulating and formatting text sequences.
public model String implements Addition<This> {
    var bytes: Arrayof<CharSpace>;
    /// Returns a `Maybe` with the character at a zero based index in the string.
    ///
    /// It also supports negative indexes, which will return values in reverse from the end of the string.
    /// ## Usage
    /// ```
    /// str := "This is a string";
    /// 
    /// Assert(str.At(0)).Equals(Some("T"));
    /// Assert(str.At(8)).Equals(Some("a")) 
    /// Assert(str.At(11)).Equals(Some("t"));
    /// ```
    /// _Indexing from behind:_
    /// 
    /// ```
    /// Assert(str.At(-1)).Equals(Some("g"));
    /// Assert(str.At(-3)).Equals(Some("i"));
    /// ```
    /// It will return no value if the length of the string is exceeded.
    public function At(position: Integer): Maybe<String> {
        Invoke(Invocation.StrAt, this, position)
    }
    /// Adds text to the end of the string.
    /// ## Usage
    /// ```
    /// str := "Hello";
    /// 
    /// str.Append(", world!");
    /// 
    /// Assert(Str).Equals("Hello, world!");
    /// ```
    // !::mutable::!
    public function Append(suffix: String) {
        Invoke(Invocation.StrAppend, this, suffix)
    }
    /// Returns an iterator over the valid characters in the string.
    /// ## Usage
    /// ```
    /// str := "adebola.io"
    /// 
    /// for char in str.Chars() {
    ///     Core.Io.Println(char);
    /// }
    /// ```
    public function Chars(): Chars {
        Invoke(Invocation.StrChars, this)
    }
    /// Empties the string of its characters.
    /// ### Usage
    /// ```
    /// str := "tralalalalaleeday";
    /// 
    /// str.Clear();
    /// 
    /// Assert(str).Equals("");
    /// Assert(str.Length()).Equals(0);
    /// ```
    // !::mutable::!
    public function Clear() {
        Invoke(Invocation.StrClear, this)
    }
    /// Returns true if a substring is contained within the string.
    /// ### Usage
    /// ```
    /// str := "This is a world premiere.";
    /// 
    /// AssertThat(str.Contains("world"));
    /// AssertThat(str.Contains("premiere"));
    /// ```
    public function Contains(substr: String): Boolean {
        Invoke(Invocation.StrContains, this, substr)
    }
    /// Returns the number of characters in the string.
    /// ### Usage
    /// ```
    /// str := "Hello";
    /// 
    /// Assert(str.Length()).Equals(5);
    /// ```
    public function Length(): Integer {
        Invoke(Invocation.StrLength, this)
    }
    /// Replaces all instances of a substring and returns the new string.
    /// ### Usage
    /// ```
    /// str := "John goes to school. John buys a book.";
    /// 
    /// str2 := str.Replace("John", "Mike");
    /// 
    /// Assert(str2).Equals("Mike goes to school. Mike buys a book.")
    /// ```
    public function Replace(substr: String, newstr: String): String {
        Invoke(Invocation.StrReplace, this, substr, newstr)
    }
    /// Returns a reversed version of the string.
    /// ### Usage
    /// ```
    /// str := "pandemonium";
    /// 
    /// str2 := str.Reverse();
    /// 
    /// Assert(str2).Equals("muinomednap");
    /// ```
    public function Reverse(): String {
        Invoke(Invocation.StrReverse, this)
    }
    /// Returns a section of the string.
    /// The range argument is exclusive, meaning it goes from the left index all the way to one before the right.
    /// ### Usage
    /// ```
    /// str := "Hello, world!";
    /// 
    /// Assert(str.Slice(0..5)).Equals("Hello"); // index 0 to 4.
    /// ```
    public function Slice(bounds: Range<Integer>): Maybe<String> {
        Invoke(Invocation.StrSlice, this, bounds)
    }
    /// Divides the string into a list of substrings based on a delimeter.
    /// ### Usage
    /// ```
    /// str := "Ring around the rosy";
    /// words := str.Split(" ");
    /// 
    /// Assert(words).Equals(["Ring", "Around", "The", "Rosy"]);
    /// ```
    public function Split(delim: String): Arrayof<String> {
        Invoke(Invocation.StrSplit, this, delim)
    }
    /// Changes the case of all letters in the string to upper case.
    /// ### Usage
    /// ```
    /// str := "hello, world!";
    /// str2 := str.ToUpperCase();
    /// 
    /// Assert(str2).Equals("HELLO, WORLD!");
    /// ```
    public function ToUpperCase(): String {
        Invoke(Invocation.StrUppercase, this)
    }
    /// Changes the case of all letters in the string to lower case.
    /// ### Usage
    /// ```
    /// str := "HELLO, WORLD!";
    /// str2 := str.ToLowerCase();
    /// 
    /// Assert(str2).Equals("hello, world!");
    /// ```
    public function ToLowerCase(): String {
        Invoke(Invocation.StrLowercase, this)
    }
    /// Returns a version of the string without left or right whitespace padding.
    /// ### Usage
    /// ```
    /// str := "\n\n\nWhat then shall we say?  \n\n\n\r\t";
    /// 
    /// Assert(str.Trim()).Equals("What then shall we say?");
    /// ```
    public function Trim(): String {
        Invoke(Invocation.StrTrim, this)
    }  
    /// Mutates the string in place and removes left or right whitespace padding.
    /// ### Usage
    /// ```
    /// str := "\n\n\nWhat then shall we say?  \n\n\n\r\t";
    /// 
    /// str.TrimInPlace();
    /// 
    /// Assert(str).Equals("What then shall we say?");
    /// ```
    // !::mutable::!
    public function TrimInPlace(): String {
        Invoke(Invocation.StrTrimInPlace, this)
    }   
    /// Returns a version of the string without left whitespace padding.
    /// ### Usage
    /// ```
    /// str := "\n\n\nWhat then shall we say?\n";
    /// 
    /// Assert(str.TrimLeft()).Equals("What then shall we say?\n");
    /// ```
    public function TrimLeft(): String {
        Invoke(Invocation.StrTrimLeft, this)
    } 
    /// Returns a version of the string without right whitespace padding.
    /// ### Usage
    /// ```
    /// str := "\nWhat then shall we say?\n\n\n";
    /// 
    /// Assert(str.TrimRight()).Equals("\nWhat then shall we say?");
    /// ```
    public function TrimRight(): String {
        Invoke(Invocation.TrimRight, this)
    }
    /// Returns a version of the string with padding on both sides.
    /// ### Usage
    /// ```
    /// str := "Alright";
    /// str2 := str.Pad(3);
    /// 
    /// Assert(str2).Equals("   Alright   "); // 3 spaces before and after.
    /// ```
    public function Pad(count: UnsignedInteger): String {
        Invoke(Invocation.StrPad, this, count)
    }
    /// Returns a version of the string with left padding.
    /// ### Usage
    /// ```
    /// str := "Alright";
    /// str2 := str.PadLeft(3);
    /// 
    /// Assert(str2).Equals("   Alright"); // 3 spaces before.
    /// ```
    public function PadLeft(count: UnsignedInteger): String {
        Invoke(Invocation.StrPadLeft, this, count)
    }
    /// Returns a version of the string with left padding.
    /// ### Usage
    /// ```
    /// str := "Alright";
    /// str2 := str.PadLeft(3);
    /// 
    /// Assert(str2).Equals("   Alright"); // 3 spaces before.
    /// ```
    public function PadRight(count: UnsignedInteger): String {
        Invoke(Invocation.StrPadRight, this, count)
    }
    /// Pads the string in place with whitespace on the left and right sides.
    /// ### Usage
    /// ```
    /// str := "Hello, world!";
    /// str.PadInPlace(3);
    /// 
    /// Assert(str).Equals("   Hello, world!   ");
    /// ```
    // !::mutable::!
    public function PadInPlace(count: UnsignedInteger): String {
        Invoke(Invocation.StrPadInPlace, this, count)
    }
    /// Adds text to the start of the string.
    /// ### Usage
    /// ```
    /// str := "world!"
    /// str.Prepend("Hello, ");
    /// 
    /// Assert(str).Equals("Hello, world!");
    /// ```
    // !::mutable::!
    public function Prepend(prefix: String) {
        Invoke(Invocation.StrPrepend, this, prefix)
    }
}


