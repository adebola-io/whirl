module Array;

use Bool.Bool;
use Numeric.{ Int, UnsignedInt };
use Ops.{ Orderable, Addition };
use Core.Prelude.{ AsIterator, Maybe, None, Some, Todo, String, Default };
use Core.Prelude.Iteration.Reversed;
use Core.Prelude.Iteratable;
use Core.Prelude.Display;
use Core.Math.{ Max, Min };
use Core.Internals.{ Injunction, Invoke };

/// A contiguous, growable list of items.
public model Array<T> implements AsIterator<T, ArrayIter<T>> {
    var length: UnsignedInt;
    new() {
        this.length = 0;
    }
    /// Returns an iterator over elements in this array.
    /// ### Usage
    /// ```
    /// ```
    public function [AsIterator.Iter](): ArrayIter<T> {
        new ArrayIter(this)
    }
    /// Returns the item at a particular index in the array, if it exists.
    /// Indexes are zero-based, meaning that the first item is at index 0.
    /// ### Usage
    /// ```
    /// arr := [1, 2, 3, 4];
    /// Assert(arr.At(0)).Equals(Some(1));
    /// Assert(arr.Ar(1)).Equals(Some(2));
    /// ```
    /// Elements can also be indexed from behind the array.
    /// Backward indexes are one-based, meaning the index -1 is the
    /// last item in the array.
    /// ```
    /// arr := [15, 25, 35, 45, 55];
    /// Assert(arr.At(-1)).Equals(Some(55))
    /// ```
    public function At(index: Int): Maybe<T> {
        i := if index < 0 {
            this.length + index
        } else {
            index
        };
        if i > this.length or i < 0 {
            return None();
        };
        a := this[i.Unsigned()];
        return Some(a);
    }
    /// Checks if an item is contained in the array.
    /// ### Usage
    /// ```
    /// str := "Hello, world";
    /// array := [];
    /// array.Push(str);
    /// 
    /// AssertThat(array.Contains(str));
    /// ```
    /// The method checks referential equality, meaning it will only return true
    /// if the checked item is in the array,
    /// and **not** if it is equivalent to an item in the array.
    /// 
    /// ```
    /// num := 24;
    /// array := [24];
    /// 
    /// AssertThat(array.Contains(num)) // This will fail, because the 24 in the array is different from the num 24.
    /// ```
    /// To check for comparative equality, consider using `.Iter().Any(...)`.
    public function Contains(value: T): Bool {
        for element in this.Iter() {
            if element is value {
                return true;
            };
        }
        return false;
    }
    /// Removes all elements in the array.
    /// ### Usage
    /// ```
    /// arr := [1, 2, 3, 4];
    /// 
    /// arr.Clear();
    /// AssertThat(arr.Length() == 0);
    /// AssertThat(arr == []);
    /// ```
    public function Clear() {
        Invoke(Injunction.ArrClear(this));
    }
    /// Returns a reference to the first item in the array, if it exists.
    /// ### Usage
    /// ```
    /// arr := [20, 30, 40, 50, 60];
    /// Assert(arr.First()).Equals(Some(20));
    /// 
    /// empty: []Int := [];
    /// Assert(empty.First()).Equals(None());
    /// ```
    public function First(): Maybe<T> {
        if this.length == 0 { None() } 
        else Some(this[0])
    }
    /// Returns the zero-based index of a value in the array.
    /// 
    /// Like the `.Contains` method, this method checks 
    /// for referential equality.
    /// ### Usage
    /// ```
    /// str1 := "Hello, world!";
    /// str2 := "Welcome to a new era!";
    /// str3 := "This is the future!";
    /// 
    /// arr := [str1, str2, str3];
    /// Assert(arr.IndexOf(str2)).Equals(Some(1)).
    /// ```
    public function IndexOf(value: T): ?UnsignedInt {
        for { a as index, b as element } in this.Iter().Enumerate() 
        {
            if element is value {
                return Some(index);
            };
        }
        return None();
    }
    /// Inserts an element at an index in the array,
    /// shifting all suceeding elements forward.
    /// ### Usage
    /// ```
    /// arr := [1, 3, 4, 5];
    /// arr.Insert(1, 2);
    /// Assert(arr.At(1)).Equals(Some(2));
    /// ```
    public function Insert(index: UnsignedInt, value: T) {
        Invoke(Injunction.ArrInsert(index, value, this));
    }
    /// Inserts all the items from another array at the start of this array,
    /// shifting all its prior elements forward.
    /// ### Usage
    /// ```
    /// arr := [5, 6, 7, 8];
    /// arr.Prepend([1, 2, 3, 4]);
    /// Assert(arr).Equals([1, 2, 3, 4, 5, 6, 7, 8]);
    /// ```
    public function Prepend(prefix: []T) {
        Invoke(Injunction.ArrPrepend(prefix, this));
    }
    /// Returns the number of items in the array.
    /// ### Usage
    /// ```
    /// arr := [1, 2, 3, 4];
    /// Assert(arr.Length()).Equals(4);
    /// ```
    public function Length(): UnsignedInt {
        return this.length;
    }
    /// Adds an item to the end of the array.
    /// ### Usage
    /// ```
    /// array := [2, 4, 6, 8];
    /// Assert(array.Length()).Equals(4);
    /// 
    /// array.Push(10);
    /// Assert(array).Equals([2, 4, 5, 8, 10]);
    /// Assert(array.Length()).Equals(5);
    /// ```
    public function Push(value: T) {
        Todo()
    }
    /// Removes an item from the end of the array.
    /// ### Usage
    /// ```
    /// array := [1, 2, 3];
    /// 
    /// array.Pop();
    /// Assert(array).Equals([1, 2]);
    /// 
    /// array.Pop();
    /// Assert(array).Equals([1]);
    /// ```
    public function Pop(): ?T {
        Todo()
    }
    /// Returns an iterator that produces elements from the end of the array
    /// to the start.
    /// ### Usage
    /// ```
    /// array := [7, 8, 9];
    /// rev := array.Reverse();
    /// 
    /// Assert(rev.Next()).Equals(Some(9));
    /// Assert(rev.Next()).Equals(Some(8));
    /// Assert(rev.Next()).Equals(Some(7));
    /// 
    /// Assert(rev.Next()).Equals(None());
    /// ```
    public function Reverse(): Reversed<T> {
        return new Reversed(this);
    }
    /// Removes the first item in the array
    /// and shifts all the other items backward
    /// by one index.
    /// 
    /// This operation has a time complexity of _O(n)_.
    /// ### Usage
    /// ```
    /// arr := [1, 2, 3, 4];
    /// firstItem := arr.Shift();
    /// 
    /// Assert(arr).Equals([2, 3, 4]);
    /// Assert(firstItem).Equals(Some(1));
    /// ```
    /// If there is no element in the array,
    /// then None() is returned, and the operation 
    /// does nothing.
    /// ```
    /// arr := [];
    /// firstItem := arr.Shift();
    /// 
    /// Assert(arr).Equals([]);
    /// Assert(firstItem).Equals(None());
    /// ```
    public function Shift(): ?T {
        if this.length == 0 {
            return None();
        } else {
            Todo()
        }
    }
    /// Returns a reference to the last item in the array.
    public function Last(): Maybe<T> {
        if this.length == 0 { None() } 
        else Some(this[this.length - 1])
    }
    /// Converts an array to a string representation,
    /// given that its elements implement `Display`.
    /// ### Usage
    /// ```
    /// arr := [1, 6, 7, 8, 10];
    /// arrAsStr := Array.ToStr(arr);
    /// 
    /// Assert(arrAsStr).Equals("[1, 6, 7, 8, 10]");
    /// ```
    public static function ToStr<T implements Display>(array: Array<T>): String {
        string := "[";
        i := 0;
        for { a as index, b as item } in array.Iter().Enumerate() 
        {
            string.Append(item.ToStr());
            if index + 1 != array.length {
                string.Append(",")
            }
        }
        string.Append("]");
        return string;
    }
    /// Sorts an array in place, given that its elements are orderable.
    /// ### Usage
    /// ```
    /// arr := [34, 21, 89, 11, 20, 46];
    /// Array.Sort(arr)
    /// Assert(arr).Equals([11, 20, 21, 34, 46, 89]);
    /// ```
    public static function Sort<T implements Orderable>(array: Array<T>) {
        Todo()
    }
    /// Returns a Sorted version of an array
    /// given that its elements are orderable.
    /// 
    /// Sorting is stable, meaning that elements that have equal ordering 
    /// remain in their original position.
    /// ### Usage
    /// ```
    /// arr := [26, 10, 35, 16, 87, 1, 12];
    /// arrSorted := Array.Sorted(arr);
    /// 
    /// Assert(arrSorted).Equals([1, 10, 12, 16, 26, 35, 87]);
    /// ```
    public static function Sorted<T implements Orderable>(array: Array<T>): Array<T> {
        Todo()
    }
    /// Fills an array with default values, given that the element type can be defaulted.
    /// ### Usage
    /// ```
    /// arr := [1, 2, 3];
    /// Array.Reset(arr);
    /// Assert(arr).Equals([0, 0, 0])
    /// ```
    public static function Reset<T implements Default>(array: Array<T>) {
        i := 0;
        while i < array.Length() {
            var def: T;
            array[i] = def;
        }
    }
    /// Returns the largest value in an array.
    /// It returns an empty value if the array is empty.
    /// ### Usage
    /// ```
    /// array := [2, 3, 4, 5, 6, 7];
    /// largest := Array.Max(array);
    /// 
    /// Assert(largest == Some(7));
    /// ```
    public static function Max<T implements Orderable>(array: Array<T>): ?T {
        max := array.First()?;
        array.Iter().ForEach(fn(value) max = Max(max, value));
        Some(max)
    }

    /// Returns the smallest value in an array.
    /// It returns an empty value if the array is empty.
    /// ### Usage
    /// ```
    /// array := [2, 3, 4, 5, 6, 7];
    /// smallest := Array.Min(array);
    /// 
    /// Assert(smallest == Some(2));
    /// ```
    public static function Min<T implements Orderable>(array: Array<T>): ?T {
        min := array.First()?;
        array.Iter().ForEach(fn(value) min = Min(min, value));
        Some(min)
    }

    /// Returns the sum of all the elements in the array.
    /// If there are no elements in the array, it returns the default value of
    /// the given type.
    /// ### Usage
    /// ```
    /// array := [1, 2, 3, 4];
    /// summed = Array.Sum(array)
    /// 
    /// AssertThat(summed == 10);
    /// ```
    public static function Sum<T implements Addition + Default>(array: Array<T>): T {
        var sum: T;
        array.Iter().ForEach(fn(item) sum += item);
        sum
    }
    /// Joins all the elements in an array into one string and returns it.
    /// 
    /// If no separator argument is specified, a single whitespace will be used instead.
    /// ### Usage
    /// ```
    /// array := ["Best", "believe", "I'm", "still", "bejeweled"];
    /// joined := Array.Join(array);
    /// 
    /// AssertThat(joined == "Best believe I'm still bejeweled");
    /// 
    /// array2 := [1, 2, 3, 4, 5];
    /// joined2 := Array.Join(array2, "+");
    /// 
    /// AssertThat(joined2 == "1+2+3+4+5");
    /// ```
    public static function Join<T implements Display>(array: Array<T>, separator?: String): String {
        separatorValue := separator.UnwrapOr(" ");
        string := new String();
        for { a as i, b as element } in array.Iter().Enumerate() 
        {
            string += element.ToStr();
            if i + 1 != array.length {
                string += separatorValue;
            }
        }
        return string;
    }
}


/// An owned iterator built from the elements of an array.
public model ArrayIter<T> implements Iteratable<T> {
    var array: Array<T>;
    var idx: UnsignedInt;
    new(array: Array<T>) {
        this.array = array;
        this.idx = 0;
    }

    public function [Iteratable.Next](): Maybe<T> {
        length := this.array.Length();
        if length == this.idx {
            return None();
        } else {
            nextItem := this.array[this.idx];
            this.idx += 1;
            return Some(nextItem);
        }
    }
}

public model ArrayRefIter<T> implements Iteratable<T> {
    var array: Array<T>;
    var idx: UnsignedInt;
    new(array: Array<T>) {
        this.array = array;
        this.idx = 0;
    }
    public function [Iteratable.Next](): Maybe<T> {
        Todo()
    }
}

/// A fixed-size list of items.
public model StaticArray<T> {
    new(size: Int, values: Array<T>) {
        // Compiler built in.
    }
}