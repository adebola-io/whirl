module Outcome;

use Super.{
    Primitives.Bool,
    Prelude.{ Try, Guaranteed, Maybe, Todo },
    Internals.{ Flow, never },
};

/// An `Outcome` is a generic (enumerated) model 
/// that represents the possible results of an operation. 
/// 
/// It has two possible inner variants:
/// - `Ok(T)`: The operation was successful and returned a value of type `T`.
/// - `Err(E)`: The operation failed and returned an error of type `E`.
/// 
/// The Outcome can be used to represent the results of fallible operations,
/// such as:
/// - reading a file, 
/// - parsing a string,
/// - executing a database query, or
/// - connecting to a server.
/// 
/// It presents a way to handle errors predictably.
public model Outcome<T, E> implements Guaranteed<T> + Try<T, Outcome<never, E>> {
    var inner: OutcomeVal<T, E>;

    /// Implementation of the Guarantee interface.
    function [Guaranteed.Guarantee](): T {
        this.Unwrap()
    }

    /// Implementation of the `Try` interface.
    function [Try.Try](): Outcome<T, Outcome<never, E>> {
        // this.inner => {
        //     .Ok(value) => Ok(Flow.Normal(value)),
        //     .Err(error) => Err(Flow.ReturnWithValue(Err(error)))
        // }
        Todo()
    }

    /// Returns the inner value if the operation was a success, or causes a runtime error otherwise.
    /// ### Usage
    /// ```
    /// outcome := Ok(9);
    /// value := outcome.Unwrap();
    /// Assert(value).Equals(9);
    /// 
    /// outcome := Err("This was an error");
    /// outcome.Unwrap(); // Will cause a runtime error.
    /// ```
    public function Unwrap(): T {
        Todo()
    }

    /// Returns true if the outcome is `Ok` 
    /// i.e. The operation was successful.
    /// ### Usage
    /// ```
    /// outcome := Ok(9)
    /// AssertThat(outcome.IsOk())
    /// ```
    public function IsOk(): Bool {
        // this.inner => {
        //     .Ok => true,
        //     .Err => false,
        // }
        Todo()
    }

    /// Returns true if the outcome is an `Err`.
    /// i.e. The operation failed.
    /// ### Usage
    /// ```
    /// outcome := Err("Something went wrong.");
    /// AssertThat(outcome.IsErr())
    /// ```
    public function IsErr(): Bool {
        !this.IsOk()
    }

    /// Checks if the outcome was successful and checks its internal value as well.
    /// ### Usage
    /// ```
    /// outcome := Ok(42);
    /// AssertThat(outcome.IsOkAnd(fn(value) value == 42));
    /// ```
    public function IsOkAnd(predicate: fn(value: &T): Bool): Bool {
        // return this.inner => {
        //     .Ok(value) => predicate(&value),
        //     _ => false,
        // };
        Todo()
    }

    /// Checks if the outcome failed and checks the error value as well.
    /// ### Usage
    /// ```
    /// outcome := Err("Something went wrong.");
    /// AssertThat(outcome.IsErrAnd(fn(e) e == "Something went wrong."));
    /// ```
    public function IsErrAnd(predicate: fn(value: &E): Bool): Bool {
        // return this.inner => {
        //     .Err(error) => predicate(&error),
        //     _ => false,
        // };
        Todo()
    }

    /// Converts an `Outcome<T, E>` to a `Maybe<T>`.
    public function Ok(): Maybe<T> {
        Todo()
    }

    /// Converts an `Outcome<T, E>` to an `Outcome<U, E>` by applying a function.
    /// ### Usage
    /// ```
    /// ok := Ok(69);
    /// err := Err("Error occurred.");
    /// 
    /// newOk := outcome.Map(fn(value) value / 3);
    /// newErr := outcome.Map(fn(value) value / 3);
    /// 
    /// AssertThat(newOk == Ok(23));
    /// AssertThat(newErr == Err("Error occurred."));
    /// ```
    public function Map<U>(predicate: fn(former: T): U): Outcome<U, E> {
        Ok(predicate(this?))
    }   

}

enum OutcomeVal<T, E> {
    Ok(T),
    Err(E)
}

/// Returns an `Outcome` with a value.
/// ### Usage
/// ```
/// outcome := Ok(9)
/// AssertThat(outcome.IsOk())
/// ```
public function Ok<T, U>(value: T): Outcome<T, U> {
    // new Outcome(OutcomeVal.Ok(value))
    Todo()
}

/// Returns an `Outcome` with an error.
/// ### Usage
/// ```
/// outcome := Err("Something went wrong.");
/// AssertThat(outcome.IsErr())
/// ```
public function Err<T, U>(errorValue: U): Outcome<T, U> {
    // new Outcome(OutcomeVal.Err(errorValue))
    Todo()
}