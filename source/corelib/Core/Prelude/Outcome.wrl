module Outcome;

use Core.{
    Primitives.Bool,
    Prelude.{ Try, Guaranteed, Maybe, Todo },
    Internals.{never, Injunction, Invoke},
    Process.FatalOnCaller
};

/// An `Outcome` is a generic (enumerated) model 
/// that represents the possible results of an operation. 
/// 
/// It has two possible inner variants:
/// - `Ok(T)`: The operation was successful and returned a value of type `T`.
/// - `Err(E)`: The operation failed and returned an error of type `E`.
/// 
/// The Outcome can be used to represent the results of fallible operations,
/// such as:
/// - reading a file, 
/// - parsing a string,
/// - executing a database query, or
/// - connecting to a server.
/// 
/// It presents a way to handle errors predictably.
public model Outcome<T, E> implements Guaranteed<T> + Try<T, Outcome<never, E>> {
    var value: OutcomeVal;
    /// Implementation of the Guarantee interface.
    function [Guaranteed.Guarantee](): T {
        this.Unwrap()
    }
    /// Implementation of the `Try` interface.
    function [Try.Try](): Outcome<T, Outcome<never, E>> {
        if this.IsOk() {
            return Ok(this.Unwrap());
        } else {
            return Todo();
        }
    }
    /// Returns the inner value if the operation was a success, or causes a runtime error otherwise.
    /// ### Usage
    /// ```
    /// outcome := Ok(9);
    /// value := outcome.Unwrap();
    /// Assert(value).Equals(9);
    /// ```
    /// <!--ignore-->
    /// ```
    /// outcome := Err("This was an error");
    /// outcome.Unwrap(); // Will cause a runtime error.
    /// ```
    public function Unwrap(): T {
        if this.IsErr() {
            FatalOnCaller("Called Unwrap on an Err value.")
        }
        return Invoke(Injunction.OutcUnwrap(this));
    }
    /// Returns the inner error value if the outcome is an error, or causes a runtime error otherwise.
    /// ### Usage
    /// ```
    /// outcome := Err("An error occured.");
    /// value := outcome.AsErr();
    /// Assert(value).Equals("An error occured.");
    /// ```
    public function AsErr(): E {
        if this.IsOk() {
            FatalOnCaller("Called AsErr on an Ok value.");
        }
        return Invoke(Injunction.OutcErr(this));
    }
    /// Returns true if the outcome is `Ok` 
    /// i.e. The operation was successful.
    /// ### Usage
    /// ```
    /// outcome := Ok(9)
    /// AssertThat(outcome.IsOk())
    /// ```
    public function IsOk(): Bool {
        return this.value == OutcomeVal.Ok;
    }

    /// Returns true if the outcome is an `Err`.
    /// i.e. The operation failed.
    /// ### Usage
    /// ```
    /// outcome := Err("Something went wrong.");
    /// AssertThat(outcome.IsErr())
    /// ```
    public function IsErr(): Bool {
        return this.value == OutcomeVal.Err;
    }
    /// Checks if the outcome was successful and checks its internal value as well.
    /// ### Usage
    /// ```
    /// outcome := Ok(42);
    /// AssertThat(outcome.IsOkAnd(fn(value) value == 42));
    /// ```
    public function IsOkAnd(predicate: fn(value: T): Bool): Bool {
        // return this.inner => {
        //     .Ok(value) => predicate(value),
        //     _ => false,
        // };
        Todo()
    }
    /// Checks if the outcome failed and checks the error value as well.
    /// ### Usage
    /// ```
    /// outcome := Err("Something went wrong.");
    /// AssertThat(outcome.IsErrAnd(fn(e) e == "Something went wrong."));
    /// ```
    public function IsErrAnd(predicate: fn(value: E): Bool): Bool {
        // return this.inner => {
        //     .Err(error) => predicate(error),
        //     _ => false,
        // };
        Todo()
    }
    /// Converts an `Outcome<T, E>` to a `Maybe<T>`.
    public function Ok(): ?T {
        if this.IsOk() {
            return Some(this.Unwrap());
        } else {
            return None();
        }
    }
    /// Converts an `Outcome<T, E>` to an `Outcome<U, E>` by applying a function.
    /// ### Usage
    /// ```
    /// ok := Ok(69);
    /// err := Err("Error occurred.");
    /// 
    /// newOk := outcome.Map(fn(value) value / 3);
    /// newErr := outcome.Map(fn(value) value / 3);
    /// 
    /// AssertThat(newOk == Ok(23));
    /// AssertThat(newErr == Err("Error occurred."));
    /// ```
    public function Map<U>(predicate: fn(former: T): U): Outcome<U, E> {
        Ok(predicate(this?))
    }   

}

enum OutcomeVal {
    Ok,
    Err
}

/// Returns an `Outcome` with a value.
/// ### Usage
/// ```
/// outcome := Ok(9)
/// AssertThat(outcome.IsOk())
/// ```
public function Ok<T, U>(value: T): Outcome<T, U> {
    // new Outcome(OutcomeVal.Ok(value))
    Todo()
}

/// Returns an `Outcome` with an error.
/// ### Usage
/// ```
/// outcome := Err("Something went wrong.");
/// AssertThat(outcome.IsErr())
/// ```
public function Err<T, U>(error: U): Outcome<T, U> {
    // new Outcome(OutcomeVal.Err(errorValue))
    Todo()
}