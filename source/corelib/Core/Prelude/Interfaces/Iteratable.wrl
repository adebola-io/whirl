module Iteratable;

use Super.Array;
use Super.Bool;
use Super.Todo;
use Super.Maybe;

/// ## The Iteratable interface
/// The Iteratable interface is a common abstraction that allows different types of collections to be traversed in a uniform way. 
/// It defines a set of methods that can be used to access and manipulate the elements of a collection, such as arrays, lists, sets, maps, etc.
///
/// It is usually specified as a generic parameter or an associated type. 
/// The `Next()` method is the core method that moves the iterator forward and returns the next element, 
/// or `None` if there are no more elements. 
/// 
/// The Iteratable interface also provides many other methods that are implemented based on the next method. 
/// These methods can perform various operations on the elements of the iterator, 
/// such as filtering, mapping, folding, counting, etc.
///  
/// Some of these methods consume the iterator and return a single value, 
/// while others return another iterator that can be chained with further methods.
/// The Iteratable interface can be implemented for any type that represents a sequence of values. 
/// 
/// Optionally, one can also override some of the default methods to provide more efficient or customized behavior.
public interface Iteratable<I> {
    /// Returns the next item in the iteration.
    public function Next(): Maybe<I>;
    /// Gathers all the items left in the iterator into an array.
    public function Collect(): Array<I> {
        // array := Todo();
        // for item in this {
        //     array.Push(item);
        // }
        Todo()
    }
    /// Returns an iterator that only yields items that match a predicate.
    /// ### Usage
    /// ```
    /// ```
    public function Filter(predicate: fn(value: &I): Bool): Filter<I, This> {
        Todo()
    }
    public function Map<J>(predicate: fn(value: I): J): Map<I, This> {
        Todo()
    }
    /// Checks if any of the elements produced by the iterator matches a predicate.
    /// 
    /// The method is shortcircuiting, therefore if there are elements left 
    /// after the target element is found, the iterator can still be used.
    /// ### Usage
    /// ```
    /// iterator := [11, 12, 13, 14, 15].IntoIter();
    /// 
    /// AssertThat(iterator.Any(fn(x) x % 2 == 0)); // Returns true at 12.
    /// // Iterator can still be used.
    /// Assert(iterator.Next()).Equals(Some(13));
    /// Assert(iterator.Next()).Equals(Some(14));
    /// ```
    public function Any(predicate: fn(value: &I): Bool): Bool {
        Todo()
    }
    /// Returns true if all the elements produced by the iterator match a predicate.
    /// ### Usage
    /// ```
    /// iter := [3, 6, 9, 12, 15].IntoIter();
    /// 
    /// AssertThat(iter.All(fn(x) x % 3 == 0)) // Consumes the entire iterator and returns true.
    /// ```
    /// Like the `.Any()` method, `.All()` is also shortcircuiting, meaning it will stop advancing after the first
    /// false item, whether or not there are still items in the iterator.
    /// ```
    /// iter := [12, 14, 15, 17, 18, 20].IntoIter();
    /// 
    /// AssertThat(!iter.All(fn(x) x > 16)); // Halts at 17 and returns false.
    /// // Iterator can still be used.
    /// Assert(iter.Next()).Equals(Some(18));
    /// Assert(iter.Next()).Equals(Some(20));
    /// ```
    public function All(predicate: fn(value: &I): Bool): Bool {
        Todo()
    }
    public function Enumerate(): Enumerate<This> {

    }
}

public interface Enumerate<I, J implements Iteratable<I>>> implements Iteratable<I> {

}

/// This interface specifies that a model can be made into an iterator.
public interface AsIterator<I, T implements Iteratable<I>> {
    /// Turn a model into an iterator.
    public function IntoIter(): T;
}

public model Filter<I, J implements Iteratable<I>> implements Iteratable<I> {

}

public model Map<I, J implements Iteratable<I>> implements Iteratable<J> {}
