module Maybe;

use Core.{
    Primitives.Bool,
    Internals.{never, Injunction, Invoke},
    Process.{FatalOnCaller, Todo},
};
use Outcome.{Ok, Err, Outcome}; 
use Interfaces.{Guaranteed.Guaranteed, Try.Try, Default.Default};

/// Creates a `Maybe` with no value.
public function None<T>(): ?T {
    return Invoke(Injunction.None);
}

/// Creates a `Maybe` with an internal value.
public function Some<T>(value: T): ?T {
    return Invoke(Injunction.MayCreate(value));
}

/// A value that may or may not exist.
public model Maybe<T> implements Guaranteed<T> + Try<T, ?never> {
    /// A simple flag for marking existence or non-existence.
    var exists: Bool;
    /// The internal value.
    /// 
    /// This will point to unintialized memory if 
    /// if it is retrieved from an empty `Maybe`. 
    /// 
    /// It should **never** be accessed outside of the 
    /// internals of the model, or without first checking the
    /// flag.
    var value: T;

    /// Implementation of the `Guaranteed` interface.
    function [Guaranteed.Guarantee](): T {
        return this.Unwrap();
    }
    /// Implementation of the `Try` interface.
    function [Try.Try](): Outcome<T, ?never> {
        if this.IsSome() {
            return Ok(this.value);
        } else {
            return Err(None());
        }
    }
    /// Combines two `Maybe` values, returning the second if and only if the 
    /// first exists, and nothing otherwise.
    /// ### Usage
    /// ```
    /// 
    /// ```
    public function And<U>(conjunct: ?U): ?U {
        if this.IsSome() { conjunct } else { None() }
    }
    /// Combines two `Maybe` values into one, computing the second from the first,
    /// if and only if the first exists, and nothing otherwise.
    /// ### Usage
    /// ```
    /// ```
    public function AndThen<U>(conjunct: fn(former: T): ?U): ?U {
        if this.IsSome() { conjunct(this.value) } else { None() }
    }
    /// Unwraps the Maybe value if it exists, or crashes the running sequence 
    /// if otherwise. 
    /// 
    /// It takes in an error message that will be displayed if the
    /// later is the case.
    /// ### Usage
    /// ```
    /// maybeVal := Some("Hello, world!");
    /// Assert(maybeVal.Expect("No value in Maybe!!")).Equals("Hello, world!");
    /// ```
    public function Expect(error: String): T {
        if this.IsNone() { Fatal(Some(error)) } else { this.value }
    }
    /// Returns a Bool indicating if the Maybe contains no value.
    /// ### Usage
    /// ```
    /// noValue: ?String := None();
    /// AssertThat(noValue.IsNone());
    /// 
    /// stringValue := Some("boy");
    /// AssertThat(!stringValue.IsNone());
    /// ```
    public function IsNone(): Bool {
        this.exists
    }
    /// Returns a Bool indicating whether there is a value contained or not.
    /// ### Usage
    /// ```
    /// stringValue := Some("boy");
    /// AssertThat(stringValue.IsSome());
    /// 
    /// noValue: ?String := None();
    /// AssertThat(!noValue.IsSome());
    /// ```
    public function IsSome(): Bool {
       !this.exists
    }
    /// Returns a Bool indicating whether there is a value contained, and it
    /// upholds a given predicate.
    /// ### Usage
    /// ```
    /// predicate := fn(value: Int) value == 42;
    /// 
    /// maybeInt := Some(42);
    /// AssertThat(maybeInt.IsSomeAnd(predicate));
    /// 
    /// maybeInt2 := Some(100);
    /// AssertThat(!maybeInt2.IsSomeAnd(predicate));
    /// 
    /// maybeInt3: ?Int := None()
    /// AssertThat(!maybeInt3.IsSomeAnd(predicate));
    /// ```
    public function IsSomeAnd(predicate: fn(value: T): Bool): Bool {
        this.IsSome() and predicate(this.value)
    }
    /// Performs a computation if there is an internal value contained.
    /// ### Usage
    /// ```
    /// use Core.Io.Fmt;
    /// maybeValue := Some(42);
    /// 
    /// maybeValue.IsSomeThen(fn(value) {
    ///     message := Fmt("The value is %").Add(value);
    ///     Print(message);
    /// })
    /// ```
    public function IsSomeThen(consequent: fn(value: T)) {
        if this.IsNone() {
            return;
        };
        consequent(this.value);
    }
    /// Performs a computation if there is no value contained in the Maybe.
    public function IsNoneThen(consequent: fn()) {
        if this.IsNone() { consequent() };
    }
    /// Returns a Bool indicating whether there is no value, or there is a value and it
    /// upholds a given predicate.
    /// ### Usage
    /// ```
    /// predicate := fn(value: Int) value > 5;
    /// 
    /// maybeInt := Some(10);
    /// AssertThat(maybeInt.IsNoneOr(predicate));
    /// 
    /// maybeInt2: ?Int := None();
    /// AssertThat(maybeInt2.IsNoneOr(predicate));
    /// 
    /// maybeInt3 := Some(4);
    /// AssertThat(not maybeInt3.IsNoneOr(predicate));
    /// ```
    public function IsNoneOr(predicate: fn(value: T): Bool): Bool {
        this.IsNone() or predicate(this.Unwrap())
    }
    /// Maps a `Maybe<T>` to an `Outcome<T, E>` by passing in a fallback error
    /// value if there is nothing within.
    /// ### Usage
    /// ```
    /// ```
    public function SomeOr<E>(error: E): Outcome<T, E> {
        if this.IsNone() { Err(error) } else { Ok(this.value) }
    }
    /// Maps a `Maybe<T>` to an `Outcome<T, E>` by computing a fallback error
    /// value if there is nothing within.
    /// ### Usage
    /// ```
    /// ```
    public function SomeOrElse<E>(error: fn(): E): Outcome<T, E> {
        if this.IsNone() { Err(error()) } else { Ok(this.value) }
    }
    /// Provides a safe and concise way to combine two indeterminate values, returning the first
    /// `Maybe` if it has a value, the second if the first is empty.
    /// 
    /// ### Usage
    /// ```
    /// govname: ?String := Some("John");
    /// nickname: ?String := None();
    /// 
    /// name := govName.Or(nickname);
    /// Assert(name).Equals("John");
    /// 
    /// name2 := nickname.Or(govname);
    /// Assert(name2).Equals("John");
    /// ```
    public function Or(alternate: ?T): ?T {
        if this.IsSome() { this } else { alternate }
    }
    /// Combines two intermediate values
    public function OrElse(alternate: fn(): ?T): ?T {
        if this.IsSome() { this } else { alternate() }
    }
    /// Ignores the maybe and returns the internal value. 
    /// It will throw an error if no value is present.
    /// <!--ignore-->
    /// ### Usage
    /// ```
    /// numValue := Some(89);
    /// Assert(numValue.Unwrap()).Equals(89);
    /// ```
    /// <!--ignore-->
    /// ```
    /// noValue: ?Number = None();
    /// noValue.Unwrap(); // Will panic with an error.
    /// ```
    /// ### Panics
    /// It panics if called on a `Maybe` with no value.
    public function Unwrap(): T {
        if this.IsNone() {
            FatalOnCaller("Called Unwrap on a Maybe with no value.")
        }
        return this.value;
    }
    /// Returns the internal value, or another given value.
    public function UnwrapOr(value: T): T {
        if this.IsNone() { value } else { this.value }
    }
    /// Returns the internal value, or computes another given value.
    public function UnwrapOrElse(fallback: fn(): T): T {
        if this.IsNone() { fallback() } else { this.value }
    }
    /// Converts a `Maybe<T>` to a `Maybe<E>` by applying a transformation function.
    /// ### Usage
    /// ```
    /// double := fn(x: Number) x * 2;
    /// 
    /// first := Some(9).Map(double);
    /// Assert(first.Unwrap()).Equals(18);
    /// 
    /// second: ?Number := None().Map(double);
    /// AssertThat(double.IsNone());
    /// ```
    public function Map<U>(func: fn(former: T): U): ?U {
        Some(func(this?))
    } 
    public function Xor(other: ?T): ?T {
        if this.IsSome() and other.IsNone() {
            return this;
        }
        if this.IsNone() and other.IsSome() {
            return other;
        }
        return None();
    }
    /// Unwraps a Maybe and returns its internal value if it exists.
    /// 
    /// If it does not, it returns the default value of the internal type.
    /// ### Usage
    /// ```
    /// i := Some(50);
    /// Assert(Maybe.UnwrapOrDefault(i)).Equals(50);
    /// 
    /// j: ?UInt8 := None();
    /// Assert(Maybe.UnwrapOrDefault(j)).Equals(0); // default value for UInt8.
    /// ```
    public static function UnwrapOrDefault<U implements Default>(maybe: ?U): U {
        if maybe.IsNone() {
            var default: U;
            default
        } else {
            maybe.value
        }
    }
    /// Tranforms a `Maybe<Maybe<T>>` to a `Maybe<T>`.
    public static function Flatten<U>(maybe: ??U): ?U {
        if maybe.IsNone() { None() } else { maybe.value }
    }
}