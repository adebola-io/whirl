module Maybe;

use Super.{
    Primitives.Bool,
    Internals.{never, Injunction},
    Process.{FatalOnCaller, Todo},
}; 
use Outcome.{ Ok, Err, Outcome }; 
use Interfaces.{ Guaranteed, Try.Try, Default.Default };

/// Creates a `Maybe` with no value.
public function None<T>(): ?T {
    // Maybe {
    //     inner := MaybeVal.Some(value)
    // }
    Todo()
}

/// Creates a `Maybe` with an internal value.
public function Some<T>(value: T): ?T {
    // Maybe {
    //     inner := MaybeVal.Some(value)
    // }
    Todo()
}

/// A value that may or may not exist.
public model Maybe<T> implements Guaranteed<T> + Try<T, ?never> {
    var inner: MaybeVal;

    /// Implementation of `Guarantee` interface.
    function [Guaranteed.Guarantee](): T {
        return this.Unwrap();
    }
    /// Implementation of `Try` interface.
    function [Try.Try](): Outcome<T, ?never> {
        if this.IsSome() {
            return Ok(this.Unwrap());
        } else {
            return Err(None());
        }
    }
    /// Returns a Bool indicating if the Maybe contains no value.
    /// ### Usage
    /// ```
    /// noValue: ?String := None();
    /// AssertThat(noValue.IsNone());
    /// 
    /// stringValue := Some("boy");
    /// AssertThat(!stringValue.IsNone());
    /// ```
    public function IsNone(): Bool {
        // this.inner => {
        //     .None => true,
        //     _ => false,
        // }
        Todo()
    }
    /// Returns a Bool indicating whether there is a value contained or not.
    /// ### Usage
    /// ```
    /// stringValue := Some("boy");
    /// AssertThat(stringValue.IsSome());
    /// 
    /// noValue: ?String := None();
    /// AssertThat(!noValue.IsSome());
    /// ```
    public function IsSome(): Bool {
        // this.inner => {
        //     .Some(_) => true,
        //     .None => false,
        // }
        Todo()
    }
    /// Returns a Bool indicating whether there is a value contained, and it
    /// upholds a given predicate.
    /// ### Usage
    /// ```
    /// predicate := fn(value: &Int) value == 42;
    /// 
    /// maybeInt := Some(42);
    /// AssertThat(maybeInt.IsSomeAnd(predicate));
    /// 
    /// maybeInt2 := Some(100);
    /// AssertThat(!maybeInt2.IsSomeAnd(predicate));
    /// 
    /// maybeInt3 := None()
    /// AssertThat(!maybeInt3.IsSomeAnd(predicate));
    /// ```
    public function IsSomeAnd(predicate: fn(value: &T): Bool): Bool {
        // this.inner => {
        //     .Some(value) => predicate(&value),
        //     .None => false
        // }
        Todo()
    }
    /// Ignores the maybe and returns the internal value. 
    /// It will throw an error if no value is present.
    /// ### Usage
    /// ```
    /// numValue := Some(89);
    /// Assert(numValue.Unwrap()).Equals(89);
    /// 
    /// noValue: ?Number = None();
    /// noValue.Unwrap(); // Will panic with an error.
    /// ```
    /// ### Panics
    /// It panics if called on a `Maybe` with no value.
    public function Unwrap(): T {
        // this.inner => {
        //     .None => PanicOnCaller("Called Unwrap on a None Value"),
        //     .Some(value) => value,
        // }
        Todo()
    }
    /// Returns the internal value, or another given value.
    public function UnwrapOr(value: T): T {
        // this.inner => {
        //     .Some(innerValue) => innerValue,
        //     .None => value
        // }
        Todo()
    }
    /// Returns the internal value, or computes another given value.
    public function UnwrapOrElse(fallback: fn(): T): T {
        // this.inner => {
        //     .Some(value) => value,
        //     .None => fallback()
        // }
        Todo()
    }
    /// Converts a `Maybe<T>` to a `Maybe<E>` by applying a function.
    public function Map<U>(func: fn(former: T): U): ?U {
        Some(func(this?))
    }   
    public static function UnwrapOrDefault<U implements Default>(value: ?U): U {
        Todo()
    }
}


enum MaybeVal {
    Some,
    None
}