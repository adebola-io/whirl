/// The `Async` module contains all primitive constructs in Whirlwind
/// for the creation and utilization of concurrent processes.
module Async;

use Core.Process.Fatal;
use Core.Prelude.{Some, Array, Todo, Bool, Guaranteed, String};
use Core.Internals.{Injunction, Invoke, Sequence};
use Core.Primitives.UnsignedInt;

/// Asynchronous functions do not run automatically in Whirlwind. 
/// 
/// Instead, calling an async function produces a _`Prospect`_, 
/// which is essentially a lazy execution context for the called function.
/// 
/// A prospect provides an interface for specifying:
/// - how and when the function should run,
/// - the manner in which the values should be produced, 
/// - the callbacks to be invoked,
/// - interaction with other prospects, etc.
public model Prospect<T> {
    /// The prospect has been executed.
    var consumed: Bool;
    /// The function to execute when the run method is called.
    var func: fn(): T;

    new(func: fn(): T) {
        this.consumed = false;
        this.func = func;
    }
    /// Chains a callback to be run when the prospect completes.
    /// 
    /// It returns a new Prospect which resolves to the value returned 
    /// by the callback.
    /// ### Usage
    /// ```
    /// squared := async fn(a: Int) a * a;
    /// doubled := fn(a: Number) a * 2;
    /// 
    /// num := squared(2).Then(doubled).Run().Await();
    /// Assert(num).Equals(12); // (2 * 2) * 3
    /// ```
    /// Callbacks can be joined consecutively, and they will run in the
    /// order in which they are chained.
    /// ```
    /// prospect := async fn() Print("Hello!");
    /// prospect
    ///   .Then(fn Print("Good day!"))
    ///   .Then(fn Print("How do you do?"))
    ///   .Run();
    /// ```
    public function Then<U>(next: fn (prior?: T): U): Prospect<U> {
        if this.consumed {
            Fatal(Some("Cannot chain callback to a consumed prospect."))
        };
        new Prospect(fn next(Some(this.func())))
    }
    /// Executes a prospect.
    /// 
    /// Running a prospect produces an `Eventual`, 
    /// which is a representation of the future value expected to be 
    /// produced by the asynchronous operation. 
    /// 
    /// The operation runs in a new sequence produced by the runtime, 
    /// meaning that other operations can continue and the execution is non-blocking.
    /// 
    /// ### Usage
    /// ```
    /// async function AFunc() {
    ///     Print("Hello from prospect!");
    /// }
    /// prospect := AFunc(); // Nothing happens yet.
    /// prospect.Run(); // AFunc runs and print "Hello from prospect!".
    /// ```
    /// After the prospect completes, its entire callback chain is invoked, 
    /// in the order in which the callbacks are defined with `.Then()`.
    /// ```
    /// async function AFunc() {
    ///     Print("Hello 1");
    /// }
    /// prospect := AFunc();
    /// prospect.Then(fn() Print("Hello 2"));
    /// prospect.Run(); // Prints "Hello 1", then prints "Hello 2".
    /// ```
    /// **Once a prospect is run, it is effectively _consumed_, meaning it cannot be altered,
    /// re-run or used in interaction with other prospects.**
    /// 
    /// This means that the following code will cause an error.
    /// <!--ignore-->
    /// ```
    /// prospect2 := AFunc();
    /// prospect2.Run();
    /// prospect2.Then(fn Print("Something else.")); // Will cause an error.
    /// ```
    public function Run(): Eventual<T> {
        if this.consumed {
            Fatal(Some("Cannot rerun a consumed Prospect."));
        }
        this.consumed = true;
        return Invoke(Injunction.EventCreate(this));
    }
    /// Sets a timeout on the prospect's eventual execution. If the duration elapses 
    /// before the eventual can be resolved, it is abruptly aborted.
    public function Timeout(ms: UnsignedInt): Prospect<T> {
        Todo();
        return *this;
    }
    /// Attaches a callback that should run if the execution of the prospect fails.
    public function Recover(callback: fn(errorMessage?: String)) {
        Todo();
    }
    /// Races a prospect against another.
    /// 
    /// It returns a new prospect that will run the 
    /// two prospects concurrently. Once either eventual
    /// is resolved, its final value will be returned, and the
    /// other eventual will be immediately aborted.
    /// ### Usage
    /// ```
    /// use Core.Time.Sleep;
    /// first := async fn() {
    ///     Sleep(300); 
    ///     return "Hello!";
    /// };
    /// second := async fn() {
    ///     Sleep(500);
    ///     return "Hola!";
    /// }
    /// greeting := first.Race(second).Run().Await();
    /// Assert(greeting).Equals("Hello");
    /// ```
    public function Race(other: Prospect<T>): Prospect<T> {
        Todo()
    }
    /// Creates a prospect that produces the fastest resolved value from
    /// a list of other prospects of the same type, and immediately aborts 
    /// other eventuals in the list.
    /// ### Usage
    /// ```
    /// use Core.Time.Sleep;
    /// first := async fn() {
    ///     Sleep(100);
    ///     return 1;
    /// }
    /// second := async fn() {
    ///     Sleep(200);
    ///     return 2;
    /// }
    /// third := async fn() {
    ///     Sleep(300);
    ///     return 3;
    /// }
    /// num := Prospect.RaceAll([first, second, third]).Run().Await();
    /// Assert(num).Equals(1);
    /// ```
    public static function RaceAll<T>(prospects: Array<Prospect<T>>): Prospect<T> {
        return Todo();
    }
}


/// An eventual is an asynchronously running operation,
/// produced by calling `.Run()` on a `Prospect`.
/// 
/// It is a wrapper for the value that will _eventually_ be produced
/// when the operation ends.
public model Eventual<T> implements Guaranteed<T> {
    /// Whether or not the eventual is resolved.
    var resolved: Bool;
    /// Whether or not the eventual has been aborted.
    var aborted: Bool;
    /// A reference to the parent sequence in charge of this eventual.
    public var sequence: &Sequence;
    /// The final value to be produced. 
    /// Until the eventual is resolved, the value remains empty (points to Nullptr).
    var value: T;
    /// Returns true if the eventual has been resolved to a value.
    public function IsResolved(): Bool {
        return this.resolved;
    }
    /// Returns true if the eventual was aborted before it could finish execution.
    public function WasAborted(): Bool {
        return this.aborted;
    }
    /// Implementation of the Guaranteed interface.
    function [Guaranteed.Guarantee](): T {
        this.Unwrap()
    }
    /// It attempts to abort the eventual's execution and returns true if it is 
    /// successful.
    /// 
    /// For already aborted eventuals, it will always return true. For already 
    /// resolved eventuals, it will always return false.
    /// ### Usage
    /// ```
    /// async function AsyncPrint() {
    ///     Print("It's a good day!");
    /// }
    /// eventual := AsyncPrint().Run();
    /// if eventual.TryAbort() {
    ///     Print("Eventual was aborted.");
    /// } else {
    ///     Print("Eventual is already resolved.")
    /// }
    /// ```
    public function TryAbort(): Bool {
        if this.aborted {
            return true;
        }
        if this.resolved {
            return false;
        };
        Invoke(Injunction.EventAbort(this.sequence));
        return true;
    }
    /// Cancels the running of the eventual and discards its value.
    /// 
    /// If the eventual was already aborted, then the function does nothing.
    /// 
    /// _However, the function will crash the program if it is called
    /// on an eventual that has already been resolved._
    /// 
    /// For a safer version, use `.TryAbort()`.
    public function Abort() {
        if this.aborted {
            return;
        };
        if this.resolved {
            Fatal(Some("Cannot abort an already resolved eventual."));
        };
        Invoke(Injunction.EventAbort(this.sequence));
        this.aborted = true;
    }
    /// Blocks other operations in the enclosing sequence until the eventual is resolved.
    /// 
    /// Using Await can be tricky, because it does not pause _all_ execution.
    /// 
    /// It only pauses the parent execution sequence, which could be the main sequence or
    /// another, depending on whether it was called inside another asynchronous context or not.
    /// 
    /// It is a valid alternative to using callbacks on the source prospect, especially
    /// in situations where the value to be produced is needed before operations can
    /// continue.
    /// ### Usage
    /// ```
    /// async function WaitASec<T>(x: T): T {
    ///     Core.Time.Sleep(1000);
    ///     return x;
    /// }
    /// x := 34;
    /// y := WaitASec(x).Run().Await(); // Waits a second and produces the value.
    /// AssertThat(x == y);
    /// ```
    /// Calling `.Await()` on an already resolved eventual just returns a copy of the previously produced value.
    /// ```
    /// eventual := WaitASec().Run();
    /// 
    /// a := eventual.Await();
    /// b := eventual.Await();
    /// 
    /// AssertThat(a == b);
    /// ```
    public function Await(): T {
        if this.aborted {
            Fatal(Some("Cannot call Await on an aborted Eventual."));
        };
        if this.resolved {
            return this.value;
        };
        this.value = Invoke(Injunction.EventAwait(this.sequence));
        this.resolved = true;
        return this.value; 
    }
    /// Forces the eventual to be resolved, and panics if it isn't.
    /// 
    /// There aren't many viable reasons why you should forcefully 
    /// resolve an eventual, but it is still useful in some niche contexts.
    public function Unwrap(): T {
        if this.aborted {
            Fatal(Some("Called Unwrap() on an aborted eventual."));
        };
        if not this.resolved or this.value is Core.Internals.Nullptr {
            Fatal(Some("Called Unwrap() on an unresolved eventual."));
        };
        return this.value;
    }
}

/// Runs a prospect immediately, blocking the current execution sequence until it is finished.
///
/// ### Usage
/// ```
/// async function AsyncSquare(a: Int): Int {
///     return a * a
/// }
/// num := ToSync(AsyncSquare(2));
/// Assert(num).Equals(4) // 2 * 2.
/// ```
/// It is the same as running `.Run().Await()` on the prospect (Its implementation is quite literally that).
public function ToSync<T>(prospect: Prospect<T>): T {
    return prospect.Run().Await();
}

/// The current running sequence for an instruction.
public model CurrentSequence {
    var handle: &Sequence;
    /// Forces the current running sequence to halt for a duration.
    public static function Sleep(timeout: UnsignedInt) {
        Todo()
    }
}