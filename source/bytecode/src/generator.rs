use crate::{Block, ConstantPool, FunctionPtr, Instruction, Opcode, RegisterList, PAD};
use analyzer::{
    PathIndex, ScopeId, SemanticSymbolKind, Standpoint, SymbolIndex, TypedFunctionDeclaration,
    TypedStmnt,
};
use errors::BytecodeError;
use std::{cell::RefCell, collections::HashMap};

pub struct BytecodeObject {
    pub constants: ConstantPool,
    pub functions: Vec<FunctionPtr>,
    pub layouts: Vec<Layout>,
    pub code: Vec<u8>,
}

#[derive(Debug)]
pub struct Layout {
    pub size: usize,
    pub property_offsets: Vec<usize>,
}

/// The bytecode generator is the penultimate pass in the Whirlwind compiler.
/// It transforms the tree-like structures from the standpoint
/// into a linear sequence of bytecode instructions to be run by the virtual
/// machine.
pub struct BytecodeGenerator<'standpoint> {
    /// The standpoint to traverse.
    standpoint: &'standpoint Standpoint,
    /// Entry function.
    main: &'standpoint TypedFunctionDeclaration,
    /// Generated bytecode.
    code: Vec<u8>,
    /// Functions in the code.
    functions: FunctionManager<'standpoint>,
    /// Constants in the code.
    constants: ConstantPool,
}

pub struct FunctionManager<'standpoint> {
    /// The standpoint to traverse.
    standpoint: &'standpoint Standpoint,
    /// Maps a function's symbol index to its index in the table.
    function_lookup: RefCell<HashMap<SymbolIndex, usize>>,
    /// Function dispatch table.
    function_table: RefCell<Vec<FunctionPtr>>,
}

impl<'standpoint> FunctionManager<'standpoint> {
    /// Returns the index of a symbol in the function registry,
    /// or adds it if it doesn't exist.
    pub fn get_or_create(&self, symbol: SymbolIndex, start: usize) -> usize {
        let mut lookup = self.function_lookup.borrow_mut();
        match lookup.get(&symbol) {
            Some(index) => return *index,
            None => {
                let mut function_table = self.function_table.borrow_mut();
                let name = self.construct_function_name(symbol);
                let functionptr = FunctionPtr {
                    name,
                    start, // to be determined later.
                    calls: 0,
                };
                let index = function_table.len();
                function_table.push(functionptr);
                lookup.insert(symbol, index);
                index
            }
        }
    }
    /// Constructs the name of a function based on its signature
    fn construct_function_name(&self, symbol: SymbolIndex) -> String {
        let standpoint = self.standpoint;
        let symbol = standpoint.symbol_library.get(symbol).unwrap();
        match &symbol.kind {
            SemanticSymbolKind::Method {
                owner_model_or_interface,
                ..
            } => {
                let owner = standpoint
                    .symbol_library
                    .get(*owner_model_or_interface)
                    .unwrap();
                format!("{}.{}", owner.name, symbol.name)
            }
            SemanticSymbolKind::Function { .. } => format!("{}", symbol.name),
            _ => unreachable!(),
        }
    }
    /// Creates the main() function.
    fn main(&mut self, main_symbol: SymbolIndex) -> usize {
        let mut function_map = self.function_lookup.borrow_mut();
        let mut list = self.function_table.borrow_mut();

        assert!(list.is_empty());

        function_map.insert(main_symbol, 0);
        list.push(FunctionPtr::main());
        0
    }
}

impl From<BytecodeGenerator<'_>> for BytecodeObject {
    fn from(value: BytecodeGenerator<'_>) -> Self {
        BytecodeObject {
            constants: value.constants,
            functions: value.functions.function_table.take(),
            code: value.code,
            layouts: vec![],
        }
    }
}

pub enum StackValue {
    ModelInstance,
    EnumInstance,
    OpaqueValue,
    Array,
    Boolean,
    Function,
    Number,
    None,
}

pub enum FunctionType {
    NamedFunction,
    AnonymousFunction,
}

pub struct StackFrame {
    values: HashMap<SymbolIndex, StackValue>,
}

impl<'a> BytecodeGenerator<'a> {
    pub fn from(main: &'a TypedFunctionDeclaration, standpoint: &'a Standpoint) -> Self {
        Self {
            main,
            standpoint,
            code: vec![PAD],
            constants: ConstantPool::new(),
            functions: FunctionManager {
                standpoint,
                function_lookup: RefCell::new(HashMap::new()),
                function_table: RefCell::new(vec![]),
            },
        }
    }

    /// Walks the execution context and generates bytecode.
    pub fn generate(mut self) -> Result<BytecodeObject, BytecodeError> {
        // Call function main.
        self.emit_function(self.main);
        self.exit();
        Ok(BytecodeObject::from(self))
    }

    fn emit_function(&mut self, function: &'a TypedFunctionDeclaration) {
        let index_of_function = self.functions.get_or_create(function.name, self.code.len());
        self.create_stack_frame(FunctionType::NamedFunction, index_of_function);
        self.emit_block(&function.body);
        if !function
            .body
            .statements
            .last()
            .is_some_and(|stmnt| stmnt.is_return())
        {
            self.code.push(Opcode::Return.into());
        }
    }

    /// Emits a statement.
    fn emit_statement(&mut self, statement: &'a TypedStmnt) {
        match statement {
            TypedStmnt::RecordDeclaration => todo!(),
            TypedStmnt::TestDeclaration(_) => todo!(),
            TypedStmnt::EnumDeclaration(_) => todo!(),
            TypedStmnt::UseDeclaration(_) => todo!(),
            TypedStmnt::VariableDeclaration(_) => todo!(),
            TypedStmnt::ShorthandVariableDeclaration(_) => todo!(),
            TypedStmnt::ConstantDeclaration(_) => todo!(),
            TypedStmnt::TypeDeclaration(_) => todo!(),
            TypedStmnt::ModelDeclaration(_) => todo!(),
            TypedStmnt::ModuleDeclaration(_) => todo!(),
            TypedStmnt::FunctionDeclaration(_) => todo!(),
            TypedStmnt::InterfaceDeclaration(_) => todo!(),
            TypedStmnt::ExpressionStatement(_) => todo!(),
            TypedStmnt::FreeExpression(_) => todo!(),
            TypedStmnt::ReturnStatement(retty) => self.emit_return(retty),
            TypedStmnt::BreakStatement(_) => todo!(),
            TypedStmnt::ForStatement(_) => todo!(),
            TypedStmnt::WhileStatement(_) => todo!(),
            TypedStmnt::ContinueStatement(_) => todo!(),
        }
    }

    /// Opens a new frame on the stack for a specified function.
    fn create_stack_frame(&mut self, function_type: FunctionType, index: usize) {
        self.code.push(Opcode::CallNamedFunction.into());
        index
            .to_be_bytes()
            .into_iter()
            .for_each(|byte| self.code.push(byte));
    }

    fn return_from_function(&mut self) {
        self.code.push(Opcode::Return.into());
    }

    fn exit(&mut self) {
        self.code.push(Opcode::Exit.into())
    }

    fn emit_block(&mut self, body: &'a analyzer::TypedBlock) {
        self.code.push(Opcode::StartBlock.into());
        for statement in &body.statements {
            self.emit_statement(&statement)
        }
        self.code.push(Opcode::EndBlock.into());
    }

    fn emit_return(&mut self, retty: &'a analyzer::TypedReturnStatement) {
        if let Some(expression) = &retty.value {
            self.emit_expression(expression);
        }
        self.code.push(Opcode::Return.into())
    }

    fn emit_expression(&self, expression: &'a analyzer::TypedExpression) {
        todo!()
    }
}

pub fn print_instructions(instructions: &[u8]) {
    for (index, byte) in instructions.iter().enumerate() {
        if index % 10 == 0 {
            print!("\n")
        }
        print!("{:02X} ", byte);
    }
    print!("\n\n");
}
