use std::{cell::RefCell, collections::HashMap};

use crate::{Block, ConstantPool, FunctionPtr, Instruction, Opcode, RegisterList};
use analyzer::{
    PathIndex, ScopeId, SemanticSymbolKind, Standpoint, SymbolIndex, TypedFunctionDeclaration,
};
use errors::BytecodeError;

pub struct BytecodeObject {
    constants: ConstantPool,
    functions: Vec<FunctionPtr>,
    blocks: Vec<Block>,
}

/// The bytecode generator is the penultimate pass in the Whirlwind compiler.
/// It transforms the tree-like structures from the standpoint
/// into a linear sequence of bytecode instructions to be run by the virtual
/// machine.
pub struct BytecodeGenerator<'standpoint> {
    /// The standpoint to traverse.
    standpoint: &'standpoint Standpoint,
    /// Entry function.
    main: &'standpoint TypedFunctionDeclaration,
    /// Generated bytecode.
    code: Vec<u8>,
    /// Functions in the code.
    functions: FunctionCounter<'standpoint>,
}

pub struct FunctionCounter<'standpoint> {
    /// The standpoint to traverse.
    standpoint: &'standpoint Standpoint,
    /// Maps a function's symbol index to its index in the table.
    function_lookup: RefCell<HashMap<SymbolIndex, usize>>,
    /// Function dispatch table.
    function_table: RefCell<Vec<FunctionPtr>>,
}

impl<'standpoint> FunctionCounter<'standpoint> {
    pub fn get_index_of(&self, index: SymbolIndex) -> usize {
        // match self.function_lookup.get(&index) {
        //     Some(_) => todo!(),
        //     None => {}
        // }
        todo!()
    }
}

pub enum StackValue {
    ModelInstance,
    EnumInstance,
    OpaqueValue,
    Array,
    Boolean,
    Function,
    Number,
    None,
}

pub enum FunctionType {
    NamedFunction,
    AnonymousFunction,
}

pub struct StackFrame {
    values: HashMap<SymbolIndex, StackValue>,
}

impl<'a> BytecodeGenerator<'a> {
    pub fn from(main: &'a TypedFunctionDeclaration, standpoint: &'a Standpoint) -> Self {
        Self {
            main,
            standpoint,
            code: vec![],
            functions: FunctionCounter {
                standpoint,
                function_lookup: HashMap::new(),
                function_table: vec![],
            },
        }
    }

    /// Walks the execution context and generates bytecode.
    pub fn generate(mut self) -> Result<BytecodeObject, BytecodeError> {
        // Call function main.
        let function_index = self.get_or_create_function_index(self.main.name);
        self.create_stack_frame(FunctionType::NamedFunction, function_index);

        todo!()
    }

    /// Opens a new frame on the stack for a specified function.
    fn create_stack_frame(&mut self, function_type: FunctionType, index: usize) {
        self.code.push(Opcode::CallNamedFunction.into());
        index
            .to_be_bytes()
            .into_iter()
            .for_each(|byte| self.code.push(byte));
    }

    /// Gets the index of a function if it has already been added to the vtable,
    /// or adds it to the registry and returns its index if it hasn't.
    fn get_or_create_function_index(&self, name: SymbolIndex) -> usize {
        let vtable = &self.functions;
        match vtable.get(name) {
            Some(index) => return index,
            None => {
                let index = vtable.len();
                vtable.push(name);
                return index;
            }
        }
    }
}
