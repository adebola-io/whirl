use crate::{
    Block, CallablePtr, ConstantPool, FunctionRetriever, Instruction, Opcode, RegisterList, PAD,
};
use analyzer::{
    EvaluatedType, PathIndex, ScopeId, SemanticSymbolKind, Standpoint, SymbolIndex,
    TypedExpression, TypedFunctionDeclaration, TypedInterfaceProperty, TypedInterfacePropertyType,
    TypedModelProperty, TypedModelPropertyType, TypedStmnt,
};
use errors::BytecodeError;
use std::{
    cell::RefCell,
    collections::{HashMap, VecDeque},
};

pub struct BytecodeObject {
    pub constants: ConstantPool,
    pub functions: Vec<CallablePtr>,
    pub layouts: Vec<Layout>,
    pub code: Vec<u8>,
}

#[derive(Debug)]
pub struct Layout {
    pub size: usize,
    pub property_offsets: Vec<usize>,
}

/// The bytecode generator is the penultimate pass in the Whirlwind compiler.
/// It transforms the tree-like structures from the standpoint
/// into a linear sequence of bytecode instructions to be run by the virtual
/// machine.
pub struct BytecodeGenerator<'standpoint> {
    /// The standpoint to traverse.
    standpoint: &'standpoint Standpoint,
    /// Generated bytecode.
    code: Vec<u8>,
    /// Functions in the code.
    callables: FunctionManager<'standpoint>,
    /// Constants in the code.
    constants: ConstantPool,
    /// Mutable queue of callable entities to generate bytecode for.
    queue: VecDeque<Callable<'standpoint>>,
}

/// The index of a variable on the current stack frame.
pub struct StackAddress(pub u32);

/// The index of a variable in the vtable.
pub struct VTableId(pub usize);

/// The type of the caller in a call expression.
pub enum CallerNature {
    /// A function created normally.
    NamedFunction(SymbolIndex),
    /// A function created from a function expression.
    /// The stack address is the address of the caller variable.
    AnonymousFunction(StackAddress),
    /// A method on an opaque type, which will be resolved at runtime.
    VirtualMethod {
        owner_opaque_value: StackAddress,
        method_id: VTableId,
    },
    /// A method on an interface or model.
    Method(SymbolIndex),
}
/// An entity that can be called in the bytecode.
pub enum Callable<'standpoint> {
    NamedFunction(&'standpoint TypedFunctionDeclaration),
    NamedModelMethod(&'standpoint TypedModelProperty),
    NamedInterfaceMethod(&'standpoint TypedInterfaceProperty),
}

pub struct FunctionManager<'standpoint> {
    /// The standpoint to traverse.
    standpoint: &'standpoint Standpoint,
    /// Maps a function's symbol index to its index in the table.
    function_lookup: RefCell<HashMap<SymbolIndex, usize>>,
    /// Function dispatch table.
    function_table: RefCell<Vec<CallablePtr>>,
}

impl<'standpoint> FunctionManager<'standpoint> {
    /// Returns the index of a symbol in the function registry,
    /// or adds it if it doesn't exist.
    pub fn get_or_create(&self, symbol: SymbolIndex) -> usize {
        let mut lookup = self.function_lookup.borrow_mut();
        match lookup.get(&symbol) {
            Some(index) => return *index,
            None => {
                let mut function_table = self.function_table.borrow_mut();
                let functionptr = self.construct_callableptr(symbol);
                let index = function_table.len();
                function_table.push(functionptr);
                lookup.insert(symbol, index);
                index
            }
        }
    }
    /// Returns true if a function has been added to the dispatch table.
    pub fn has(&self, function_symbol: SymbolIndex) -> bool {
        self.function_lookup
            .borrow()
            .get(&function_symbol)
            .is_some()
    }
    /// Constructs a callable pointer to store in the dispatch table,
    /// based on the symbol signature
    fn construct_callableptr(&self, symbol: SymbolIndex) -> CallablePtr {
        let standpoint = self.standpoint;
        let symbol = standpoint.symbol_library.get(symbol).unwrap();
        let (name, param_count) = match &symbol.kind {
            SemanticSymbolKind::Method {
                owner_model_or_interface,
                params,
                ..
            } => {
                let owner = standpoint
                    .symbol_library
                    .get(*owner_model_or_interface)
                    .unwrap();
                (format!("{}.{}", owner.name, symbol.name), params.len())
            }
            SemanticSymbolKind::Function { params, .. } => {
                (format!("{}", symbol.name), params.len())
            }
            _ => unreachable!(),
        };
        CallablePtr {
            name,
            param_count,
            start: 0, // to be determined when the function is actually reached.
            calls: 0,
        }
    }
    /// Creates the main() function.
    fn main(&mut self, main_symbol: SymbolIndex) -> usize {
        let mut function_map = self.function_lookup.borrow_mut();
        let mut list = self.function_table.borrow_mut();

        assert!(list.is_empty());

        function_map.insert(main_symbol, 0);
        list.push(CallablePtr::main());
        0
    }

    /// Creates or gets a function index while setting its starting instruction idx.
    fn set_start(&mut self, name: SymbolIndex, start: usize) -> usize {
        let idx_in_function_list = self.get_or_create(name);
        let mut function_list = self.function_table.borrow_mut();
        function_list[idx_in_function_list].start = start;
        return idx_in_function_list;
    }
}

impl From<BytecodeGenerator<'_>> for BytecodeObject {
    fn from(value: BytecodeGenerator<'_>) -> Self {
        BytecodeObject {
            constants: value.constants,
            functions: value.callables.function_table.take(),
            code: value.code,
            layouts: vec![],
        }
    }
}

pub enum Value {
    ModelInstance,
    EnumInstance,
    OpaqueValue,
    Array,
    Boolean,
    Function,
    Number,
    None,
}

pub enum FunctionType {
    NamedFunction,
    AnonymousFunction,
}

pub struct StackFrame {
    values: HashMap<SymbolIndex, Value>,
}

impl<'a> BytecodeGenerator<'a> {
    pub fn from(standpoint: &'a Standpoint) -> Self {
        Self {
            standpoint,
            code: vec![PAD],
            constants: ConstantPool::new(),
            callables: FunctionManager {
                standpoint,
                function_lookup: RefCell::new(HashMap::new()),
                function_table: RefCell::new(vec![]),
            },
            queue: VecDeque::new(),
        }
    }

    /// Walks the execution context and generates bytecode.
    pub fn generate(mut self) -> Result<BytecodeObject, BytecodeError> {
        self.call_named_function(self.standpoint.main().unwrap().name);
        self.exit();
        // Build the blocks pertaining to each function in the program.
        while !self.queue.is_empty() {
            let next_function = self.queue.pop_front().unwrap();
            self.emit_callable(next_function);
        }
        Ok(BytecodeObject::from(self))
    }

    /// Emits a callable as bytecode.
    fn emit_callable(&mut self, callable: Callable<'a>) {
        // The starting position of this callable is the current length of the bytecode.
        let start = self.code.len();
        // get the callable index and the block of statements.
        let (symbol_idx, body) = match callable {
            Callable::NamedFunction(function) => (function.name, &function.body),
            Callable::NamedModelMethod(method) => match &method._type {
                TypedModelPropertyType::TypedMethod { body }
                | TypedModelPropertyType::InterfaceImpl { body, .. } => {
                    (method.name, body)
                }
                _ => unreachable!("Attempted to call an attribute while generating bytecode."),
            },
            Callable::NamedInterfaceMethod(interface) => match &interface._type {
                TypedInterfacePropertyType::Signature => unreachable!("Attempted to call an umimplemented interface method while generating bytecode."),
                TypedInterfacePropertyType::Method { body } => (interface.name, body),
            },
        };
        self.callables.set_start(symbol_idx, start);
        self.emit_block(body);
        // return if a return is not already specified.
        if !body
            .statements
            .last()
            .is_some_and(|stmnt| stmnt.is_return())
        {
            self.code.push(Opcode::Return.into());
        }
    }

    /// Emits a statement.
    fn emit_statement(&mut self, statement: &'a TypedStmnt) {
        match statement {
            TypedStmnt::RecordDeclaration => todo!(),
            TypedStmnt::TestDeclaration(_) => todo!(),
            TypedStmnt::EnumDeclaration(_) => todo!(),
            TypedStmnt::UseDeclaration(_) => todo!(),
            TypedStmnt::VariableDeclaration(_) => todo!(),
            TypedStmnt::ShorthandVariableDeclaration(_) => todo!(),
            TypedStmnt::ConstantDeclaration(_) => todo!(),
            TypedStmnt::TypeDeclaration(_) => todo!(),
            TypedStmnt::ModelDeclaration(_) => todo!(),
            TypedStmnt::ModuleDeclaration(_) => todo!(),
            TypedStmnt::FunctionDeclaration(function) => {
                self.emit_callable(Callable::NamedFunction(function))
            }
            TypedStmnt::InterfaceDeclaration(_) => todo!(),
            TypedStmnt::ExpressionStatement(expression)
            | TypedStmnt::FreeExpression(expression) => {
                // Literal expression have no side effects, so they can be skipped easily.
                if expression.is_literal() {
                    return;
                }
                self.emit_expression(expression);
            }
            TypedStmnt::ReturnStatement(retty) => self.emit_return(retty),
            TypedStmnt::BreakStatement(_) => todo!(),
            TypedStmnt::ForStatement(_) => todo!(),
            TypedStmnt::WhileStatement(_) => todo!(),
            TypedStmnt::ContinueStatement(_) => todo!(),
        }
    }

    /// Opens a new frame on the stack for a named function.
    fn call_named_function(&mut self, function_symbol: SymbolIndex) -> Value {
        let has_been_added = self.callables.has(function_symbol);
        let index = self.callables.get_or_create(function_symbol);
        // Adds the call instruction to the bytecode.
        self.code.push(Opcode::CallNamedFunction.into());
        (index as u32)
            .to_be_bytes()
            .into_iter()
            .for_each(|byte| self.code.push(byte));
        // Enqueue the function to be generated, if it is not already.
        if !has_been_added {
            let function_symbol = self.standpoint.symbol_library.get(function_symbol).unwrap();
            let retriever = FunctionRetriever::new(self.standpoint, function_symbol);
            let function = retriever.retrieve().unwrap();
            self.queue.push_back(Callable::NamedFunction(function));
        }
        Value::None
    }

    fn exit(&mut self) {
        self.code.push(Opcode::Exit.into())
    }

    fn emit_block(&mut self, body: &'a analyzer::TypedBlock) {
        self.code.push(Opcode::StartBlock.into());
        for statement in &body.statements {
            self.emit_statement(&statement)
        }
        self.code.push(Opcode::EndBlock.into());
    }

    /// Emits a return statement.
    ///
    /// It evaluates the return value and moves the value into the return register.
    fn emit_return(&mut self, retty: &'a analyzer::TypedReturnStatement) {
        if let Some(expression) = &retty.value {
            self.emit_expression(expression);
            self.code.push(Opcode::MoveValtoRet.into())
        }
        self.code.push(Opcode::Return.into())
    }

    fn emit_expression(&mut self, expression: &'a TypedExpression) -> Value {
        match expression {
            TypedExpression::Identifier(id) => Value::None,
            TypedExpression::Literal(_) => todo!(),
            TypedExpression::NewExpr(_) => todo!(),
            TypedExpression::ThisExpr(_) => todo!(),
            TypedExpression::CallExpr(call) => self.emit_call_expression(call),
            TypedExpression::FnExpr(_) => todo!(),
            TypedExpression::Block(block) => todo!(),
            TypedExpression::IfExpr(_) => todo!(),
            TypedExpression::AccessExpr(_) => todo!(),
            TypedExpression::ArrayExpr(_) => todo!(),
            TypedExpression::IndexExpr(_) => todo!(),
            TypedExpression::BinaryExpr(_) => todo!(),
            TypedExpression::AssignmentExpr(_) => todo!(),
            TypedExpression::UnaryExpr(_) => todo!(),
            TypedExpression::LogicExpr(_) => todo!(),
            TypedExpression::UpdateExpr(_) => todo!(),
        }
    }

    /// Emits a call expression.
    ///
    /// It loads the parameters to the stack from left to right,
    /// then calls the function.
    fn emit_call_expression(&mut self, call: &'a analyzer::TypedCallExpr) -> Value {
        // todo: load parameters.
        // todo: load optional parameters.
        self.emit_expression(&call.caller);
        match self.get_caller_nature(&call.caller) {
            CallerNature::NamedFunction(idx) => self.call_named_function(idx),
            CallerNature::AnonymousFunction(stackaddress) => todo!(),
            CallerNature::Method(_) => todo!(),
            CallerNature::VirtualMethod { .. } => todo!(),
        }
    }

    /// Returns the nature of the caller in the call expression.
    fn get_caller_nature(&mut self, caller: &TypedExpression) -> CallerNature {
        if caller.is_identifier() {
            let literals = &self.standpoint.literals;
            let library = &self.standpoint.symbol_library;
            let type_of_callable = library.get_expression_type(caller, literals).unwrap();
            match type_of_callable {
                EvaluatedType::FunctionInstance { function, .. } => {
                    return CallerNature::NamedFunction(function)
                }
                EvaluatedType::MethodInstance { method, .. } => {
                    return CallerNature::Method(method)
                }
                EvaluatedType::FunctionExpressionInstance { .. } => todo!(),
                _ => unreachable!("Could not construct nature on non-callable value."),
            }
        }
        todo!()
    }
}

pub fn print_instructions(instructions: &[u8]) {
    for (index, byte) in instructions.iter().enumerate() {
        if index % 10 == 0 {
            print!("\n")
        }
        print!("{:02X} ", byte);
    }
    print!("\n\n");
}
