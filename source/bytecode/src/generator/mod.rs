use crate::{Block, ConstantPool, FunctionRetriever, Instruction, Opcode, RegisterList, PAD};
use analyzer::{
    EvaluatedType, PathIndex, ScopeId, SemanticSymbolKind, Standpoint, SymbolIndex,
    TypedExpression, TypedFunctionDeclaration, TypedInterfaceProperty, TypedInterfacePropertyType,
    TypedModelProperty, TypedModelPropertyType, TypedStmnt,
};
use errors::BytecodeError;
use std::{
    cell::RefCell,
    collections::{HashMap, VecDeque},
};

mod callable;

pub use callable::*;

pub struct BytecodeObject {
    pub constants: ConstantPool,
    pub functions: Vec<CallablePtr>,
    pub layouts: Vec<Layout>,
    pub code: Vec<u8>,
}

#[derive(Debug)]
pub struct Layout {
    pub size: usize,
    pub property_offsets: Vec<usize>,
}

/// The bytecode generator is the penultimate pass in the Whirlwind compiler.
/// It transforms the tree-like structures from the standpoint
/// into a linear sequence of bytecode instructions to be run by the virtual
/// machine.
pub struct BytecodeGenerator<'standpoint> {
    /// The standpoint to traverse.
    standpoint: &'standpoint Standpoint,
    /// Generated bytecode.
    code: Vec<u8>,
    /// Functions in the code.
    callables: Callables<'standpoint>,
    /// Constants in the code.
    constants: ConstantPool,
    /// Mutable queue of callable entities to generate bytecode for.
    queue: VecDeque<Callable<'standpoint>>,
}

/// The index of a variable on the current stack frame.
pub struct StackAddress(pub u32);

impl From<BytecodeGenerator<'_>> for BytecodeObject {
    fn from(value: BytecodeGenerator<'_>) -> Self {
        BytecodeObject {
            constants: value.constants,
            functions: value.callables.table.take(),
            code: value.code,
            layouts: vec![],
        }
    }
}

pub enum Value {
    ModelInstance,
    EnumInstance,
    OpaqueValue,
    Array,
    Boolean,
    Function,
    Number,
    None,
}

pub enum FunctionType {
    NamedFunction,
    AnonymousFunction,
}

pub struct StackFrame {
    values: HashMap<SymbolIndex, Value>,
}

impl<'a> BytecodeGenerator<'a> {
    pub fn from(standpoint: &'a Standpoint) -> Self {
        Self {
            standpoint,
            code: vec![PAD],
            constants: ConstantPool::new(),
            callables: Callables {
                standpoint,
                lookup: RefCell::new(HashMap::new()),
                table: RefCell::new(vec![]),
            },
            queue: VecDeque::new(),
        }
    }

    /// Walks the execution context and generates bytecode.
    pub fn generate(mut self) -> Result<BytecodeObject, BytecodeError> {
        self.call_named_function(self.standpoint.main().unwrap().name);
        self.exit();
        // Build the blocks pertaining to each function in the program.
        while !self.queue.is_empty() {
            let next_function = self.queue.pop_front().unwrap();
            self.emit_callable(next_function);
        }
        Ok(BytecodeObject::from(self))
    }

    /// Emits a callable as bytecode.
    fn emit_callable(&mut self, callable: Callable<'a>) {
        // The starting position of this callable is the current length of the bytecode.
        let start = self.code.len();
        // get the callable index and the block of statements.
        let (symbol_idx, body) = match callable {
            Callable::NamedFunction(function) => (function.name, &function.body),
            Callable::NamedModelMethod(method) => match &method._type {
                TypedModelPropertyType::TypedMethod { body }
                | TypedModelPropertyType::InterfaceImpl { body, .. } => {
                    (method.name, body)
                }
                _ => unreachable!("Attempted to call an attribute while generating bytecode."),
            },
            Callable::NamedInterfaceMethod(interface) => match &interface._type {
                TypedInterfacePropertyType::Signature => unreachable!("Attempted to call an umimplemented interface method while generating bytecode."),
                TypedInterfacePropertyType::Method { body } => (interface.name, body),
            },
        };
        self.callables.set_start(symbol_idx, start);
        self.emit_block(body);
        // return if a return is not already specified.
        if !body
            .statements
            .last()
            .is_some_and(|stmnt| stmnt.is_return())
        {
            self.code.push(Opcode::Return.into());
        }
    }

    /// Emits a statement.
    fn emit_statement(&mut self, statement: &'a TypedStmnt) {
        match statement {
            TypedStmnt::RecordDeclaration => todo!(),
            TypedStmnt::TestDeclaration(_) => todo!(),
            TypedStmnt::EnumDeclaration(_) => todo!(),
            TypedStmnt::UseDeclaration(_) => todo!(),
            TypedStmnt::VariableDeclaration(_) => todo!(),
            TypedStmnt::ShorthandVariableDeclaration(_) => todo!(),
            TypedStmnt::ConstantDeclaration(_) => todo!(),
            TypedStmnt::TypeDeclaration(_) => todo!(),
            TypedStmnt::ModelDeclaration(_) => todo!(),
            TypedStmnt::ModuleDeclaration(_) => todo!(),
            TypedStmnt::FunctionDeclaration(function) => {
                self.emit_callable(Callable::NamedFunction(function))
            }
            TypedStmnt::InterfaceDeclaration(_) => todo!(),
            TypedStmnt::ExpressionStatement(expression)
            | TypedStmnt::FreeExpression(expression) => {
                // Literal expression have no side effects, so they can be skipped easily.
                if expression.is_literal() {
                    return;
                }
                self.emit_expression(expression);
            }
            TypedStmnt::ReturnStatement(retty) => self.emit_return(retty),
            TypedStmnt::BreakStatement(_) => todo!(),
            TypedStmnt::ForStatement(_) => todo!(),
            TypedStmnt::WhileStatement(_) => todo!(),
            TypedStmnt::ContinueStatement(_) => todo!(),
        }
    }

    /// Opens a new frame on the stack for a named function.
    fn call_named_function(&mut self, function_symbol: SymbolIndex) {
        let has_been_added = self.callables.has(function_symbol);
        let index = self.callables.get_or_create(function_symbol);
        // Adds the call instruction to the bytecode.
        self.code.push(Opcode::CallNamedFunction.into());
        (index as u32)
            .to_be_bytes()
            .into_iter()
            .for_each(|byte| self.code.push(byte));
        // Enqueue the function to be generated, if it is not already.
        if !has_been_added {
            let function_symbol = self.standpoint.symbol_library.get(function_symbol).unwrap();
            let retriever = FunctionRetriever::new(self.standpoint, function_symbol);
            let function = retriever.retrieve().unwrap();
            self.queue.push_back(Callable::NamedFunction(function));
        }
    }

    fn exit(&mut self) {
        self.code.push(Opcode::Exit.into())
    }

    fn emit_block(&mut self, body: &'a analyzer::TypedBlock) {
        self.code.push(Opcode::StartBlock.into());
        for statement in &body.statements {
            self.emit_statement(&statement)
        }
        self.code.push(Opcode::EndBlock.into());
    }

    /// Emits a return statement.
    ///
    /// It evaluates the return value and moves the value into the return register.
    fn emit_return(&mut self, retty: &'a analyzer::TypedReturnStatement) {
        if let Some(expression) = &retty.value {
            self.emit_expression(expression);
            self.code.push(Opcode::MoveValtoRet.into())
        }
        self.code.push(Opcode::Return.into())
    }

    fn emit_expression(&mut self, expression: &'a TypedExpression) {
        match expression {
            TypedExpression::Identifier(id) => {}
            TypedExpression::Literal(_) => todo!(),
            TypedExpression::NewExpr(_) => todo!(),
            TypedExpression::ThisExpr(_) => todo!(),
            TypedExpression::CallExpr(call) => self.emit_call_expression(call),
            TypedExpression::FnExpr(_) => todo!(),
            TypedExpression::Block(block) => self.emit_block(block),
            TypedExpression::IfExpr(_) => todo!(),
            TypedExpression::AccessExpr(_) => todo!(),
            TypedExpression::ArrayExpr(_) => todo!(),
            TypedExpression::IndexExpr(_) => todo!(),
            TypedExpression::BinaryExpr(_) => todo!(),
            TypedExpression::AssignmentExpr(_) => todo!(),
            TypedExpression::UnaryExpr(_) => todo!(),
            TypedExpression::LogicExpr(_) => todo!(),
            TypedExpression::UpdateExpr(_) => todo!(),
        }
    }

    /// Emits a call expression.
    ///
    /// It loads the parameters to the stack from left to right,
    /// then calls the function.
    fn emit_call_expression(&mut self, call: &'a analyzer::TypedCallExpr) {
        // todo: load parameters.
        // todo: load optional parameters.
        self.emit_expression(&call.caller);
        match self.get_caller_nature(&call.caller) {
            CallerNature::NamedFunction(idx) => self.call_named_function(idx),
            CallerNature::AnonymousFunction(stackaddress) => todo!(),
            CallerNature::Method(_) => todo!(),
            CallerNature::VirtualMethod { .. } => todo!(),
        }
    }

    /// Returns the nature of the caller in the call expression.
    fn get_caller_nature(&mut self, caller: &TypedExpression) -> CallerNature {
        if caller.is_identifier() {
            let literals = &self.standpoint.literals;
            let library = &self.standpoint.symbol_library;
            let type_of_callable = library.get_expression_type(caller, literals).unwrap();
            match type_of_callable {
                EvaluatedType::FunctionInstance { function, .. } => {
                    return CallerNature::NamedFunction(function)
                }
                EvaluatedType::MethodInstance { method, .. } => {
                    return CallerNature::Method(method)
                }
                EvaluatedType::FunctionExpressionInstance { .. } => todo!(),
                _ => unreachable!("Could not construct nature on non-callable value."),
            }
        }
        todo!()
    }
}

pub fn print_instructions(instructions: &[u8]) {
    for (index, byte) in instructions.iter().enumerate() {
        if index % 10 == 0 {
            print!("\n")
        }
        print!("{:02X} ", byte);
    }
    print!("\n\n");
}
