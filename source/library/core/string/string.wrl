module string

use core.array.{Array, ArrayIter}
use core.boolean.boolean
use core.collections.Hash
use core.interfaces.Default
use core.iterate.{AsIterator, Iterable}
use core.maybe.some
use core.numeric.i32
use core.ops.{Addition, Range}
use core.sentinels.todo

public use display.Display
public use coloredstring.ColoredString
public use template.Template

/// Model for creating, manipulating and formatting text sequences.
public model string 
    implements Addition 
    + AsIterator<string, Chars> 
    + Default
    + Display
    + Hash
{
    var vec: []i32

    new(vec: []i32) {
        this.vec = vec
    }

    /// Implementation of the Display trait.
    public function [Display.toStr] -> string {
       return '"' + this.replace('"', '\\"') + '"'
    }
    /// Implementation of the Default trait.
    static function [Default.init] -> This {
        return ""
    }
    /// Adds two strings together.
    /// ## Usage
    /// ```
    /// var str = "Hello" + ", world!"
    /// assert(str).equals("Hello, world!")
    /// ```
    public function [Addition.add](other: This) -> This {
        var newString = this
        newString.vec.append(this.vec)
        return newString
    }
    /// Creates an iterator from the contents of a string.
    /// ## Usage
    /// ```
    /// var str = "This is a string"
    /// for char in str {
    ///     print(char)
    /// }
    /// ```
    public function [AsIterator.iter] -> Chars {
        return Chars(this.vec.iter())
    }
    /// Adds text to the end of the string.
    /// ## Usage
    /// ```
    /// var str = "Hello"
    /// str.append(", world!")
    /// 
    /// assert(str).equals("Hello, world!")
    /// ```
    public function append(suffix: string) {
        this.vec.append(suffix.vec)
    }
    /// Converts the string to an array of bytes.
    /// ### Usage
    /// ```
    /// ```
    public function bytes -> []i32 {
        return this.vec
    }
    /// Changes the first character of every word in the string to upper case.
    /// ## Usage
    /// ```
    /// var str = "jonathan is a boy"
    /// var str2 = str.capitalCase()
    /// 
    /// assert(str2).equals("Jonathan Is A Boy")
    /// ```
    public function capitalCase -> string {
        todo()
    }
    /// Returns an iterator over the valid characters in the string.
    /// ## Usage
    /// ```
    /// var str = "adebola.io"
    /// 
    /// for char in str.characters() {
    ///     print(char)
    /// }
    /// ```
    public function characters -> Chars {
        return Chars(this.vec.iter())
    }
    /// Empties the string of its characters.
    /// ## Usage
    /// ```
    /// var str = "tralalalalaleeday"
    /// str.clear()
    /// 
    /// assert(str).equals("")
    /// assert(str.length()).equals(0)
    /// ```
    public function clear {
        this.vec = Array(this.vec.capacity())
    }
    /// Returns true if a substring is contained within the string.
    /// ## Usage
    /// ```
    /// var str = "This is a world premiere."
    /// 
    /// assertThat(str.contains("world"))
    /// assertThat(str.contains("premiere"))
    /// ```
    public function contains(substr: string) -> boolean {
       return this.vec.includes(substr.vec)
    }
    /// Returns true if the string ends with a given pattern.
    /// ### Usage
    /// ```
    /// var name = "Michael"
    /// assertThat(name.endsWith("l"))
    /// assertThat(name.endsWith("ael"))
    /// ```
    public function endsWith(pat: string) -> boolean {
        var thisIter = this.vec.reverse()
        var patternIter = pat.vec.reverse()
        thisIter.zip(patternIter).all(fn (tuple) {
            tuple.a == tuple.b
        })
    }
    /// Returns true if the string is made up entirely of alphabetic and numeric characters.
    /// ## Usage
    /// ```
    /// var str = "helloworld1234"
    /// assertThat(str.isAlphanumeric())
    /// 
    /// var str2 = "%hello_world$"
    /// assertThat(!str2.isAlphanumeric())
    /// ```
    public function isAlphanumeric -> boolean {
        todo()
    }
    /// Returns true if the string has no characters.
    /// ## Usage
    /// ```
    /// var str = ""
    /// assertThat(str.isEmpty())
    /// 
    /// str.append("Hello")
    /// assertThat(!str.isEmpty())
    /// ```
    public function isEmpty -> boolean {
        return this.vec.length() == 0
    }
    /// Returns the number of bytes in the string.
    /// ## Usage
    /// ```
    /// var str = "Hello"
    /// assert(str.length()).equals(5)
    /// ```
    public function length -> i32 {
        return this.vec.length()
    }
    /// Changes the case of all letters in the string to lower case.
    /// ## Usage
    /// ```
    /// var str = "HELLO, WORLD!"
    /// var str2 = str.lowerCase()
    /// 
    /// assert(str2).equals("hello, world!")
    /// ```
    public function lowerCase -> string {
        todo()
    }
    /// Returns a version of the string with padding on both sides.
    /// ## Usage
    /// ```
    /// var str = "Alright"
    /// var str2 = str.pad(3)
    /// 
    /// assert(str2).equals("   Alright   ") // 3 spaces before and after.
    /// ```
    public function pad(count: i32) -> string {
        todo()
    }
    /// Returns a version of the string with left padding.
    /// ## Usage
    /// ```
    /// var str = "Alright"
    /// var str2 = str.padLeft(3)
    /// 
    /// assert(str2).equals("   Alright") // 3 spaces before.
    /// ```
    public function padLeft(count: i32) -> string {
        todo()
    }
    /// Returns a version of the string with left padding.
    /// ## Usage
    /// ```
    /// var str = "Alright"
    /// var str2 = str.padRight(3)
    /// 
    /// assert(str2).equals("Alright   ") // 3 spaces before.
    /// ```
    public function padRight(count: i32) -> string {
        todo()
    }
    /// Pads the string in place with whitespace on the left and right sides.
    /// ## Usage
    /// ```
    /// var str = "Hello, world!"
    /// str.padInPlace(3)
    /// 
    /// assert(str).equals("   Hello, world!   ")
    /// ```
    public function padInPlace(count: i32) {
        this = this.pad(count)
    }
    /// Adds text to the start of the string.
    /// ## Usage
    /// ```
    /// var str = "world!"
    /// str.prepend("Hello, ")
    /// 
    /// assert(str).equals("Hello, world!")
    /// ```
    public function prepend(prefix: string) {
        var newString = prefix
        newString += this
        this = newString
    }
    /// Returns a string value that is made from a number of copies of the original string.
    /// If count is 0, the empty string is returned.
    /// ## Usage
    /// ```
    /// var str = "Whirlwind"
    /// 
    /// var str2 = str.repeat(3)
    /// assert(str2).equals("WhirlwindWhirlwindWhirlwind") // 3 copies.
    /// 
    /// var str3 = str.repeat(1)
    /// assert(str3).equals("Whirlwind") // One copy.
    /// 
    /// var str3 = str.repeat(0)
    /// assertThat(str2.IsEmpty()) // No copies.
    /// ```
    public function repeat(count: i32) -> string {
        var str: string
        for {} in 0..count {
           str.append(this)
        }
        return str
    }
    /// Replaces all instances of a substring and returns the new string.
    /// ## Usage
    /// ```
    /// var str = "John goes to school. John buys a book."
    /// 
    /// var str2 = str.replace("John", "Mike")
    /// 
    /// assert(str2).equals("Mike goes to school. Mike buys a book.")
    /// ```
    public function replace(subStr: string, newStr: string) -> string {
        todo()
    }
    /// Returns a reversed version of the string.
    /// ## Usage
    /// ```
    /// var str = "pandemonium"
    /// 
    /// var str2 = str.reverse()
    /// 
    /// assert(str2).equals("muinomednap")
    /// ```
    public function reverse -> string {
        var newString = ""
        for char in this.characters() {
            newString = char + newString
        }
        return newString
    }
    /// Returns a section of the string.
    /// The range argument is exclusive, meaning it goes from the left index all the way to one before the right.
    /// ## Usage
    /// ```
    /// var str = "Hello, world!"
    /// 
    /// assert(str.slice(0..5)).equals(some("Hello")) // index 0 to 4.
    /// ```
    public function slice(bounds: Range<i32>) -> ?string {
        todo()
    }
    /// Divides the string into a list of substrings based on a delimeter.
    /// ## Usage
    /// ```
    /// var str = "Ring around the rosy"
    /// var words = str.split(" ")
    /// 
    /// assert(words == ["Ring", "Around", "The", "Rosy"])
    /// ```
    public function split(delim: string) -> []string {
        todo()
    }
    /// Divides the string into a list of substrings based on a predicate.
    /// ## Usage
    /// ```
    /// var str = "Hello world. My name is James."
    /// var sentences = str.splitAt(fn(pat) pat == ". ")
    /// 
    /// assert(sentences).equals(["Hello world", "My name is James."])
    /// ```
    public function splitAt(predicate: fn(pattern: string) -> boolean) -> []string {
        todo()
    }
    /// Changes only the first character in the string to upper case.
    /// ## Usage
    /// ```
    /// var str = "nice to meet you, where you been?"
    /// var str2 = str.sentenceCase()
    /// 
    /// assert(str2).equals("Nice to meet you, where you been?")
    /// ```
    public function sentenceCase -> string {
        return this.characters()
            .next()
            .map(fn (c) c.upperCase() + this.slice(1..this.length()).unwrapOr(""))
            .unwrapOr("")
    }
    /// Returns a version of the string without left or right whitespace padding.
    /// ## Usage
    /// ```
    /// var str = "\n\n\nWhat then shall we say?  \n\n\n\r\t"
    /// 
    /// assert(str.trim()).equals("What then shall we say?")
    /// ```
    public function trim -> string {
        todo()
    }  
    /// Mutates the string in place and removes left or right whitespace padding.
    /// ## Usage
    /// ```
    /// var str = "\n\n\nWhat then shall we say?  \n\n\n\r\t"
    /// 
    /// str.trimInPlace()
    /// 
    /// assert(str).equals("What then shall we say?")
    /// ```
    public function trimInPlace {
        this = this.trim()
    }   
    /// Returns a version of the string without left whitespace padding.
    /// ## Usage
    /// ```
    /// var str = "\n\n\nWhat then shall we say?\n"
    /// 
    /// assert(str.trimStart()).equals("What then shall we say?\n")
    /// ```
    public function trimStart -> string {
        todo()
    } 
    /// Returns a version of the string without right whitespace padding.
    /// ## Usage
    /// ```
    /// var str = "\nWhat then shall we say?\n\n\n"
    /// 
    /// assert(str.trimEnd()).equals("\nWhat then shall we say?")
    /// ```
    public function trimEnd -> string {
        todo()
    }
    /// Changes the case of all letters in the string to upper case.
    /// ## Usage
    /// ```
    /// var str = "hello, world!"
    /// assert(str.upperCase()).equals("HELLO, WORLD!")
    /// ```
    public function upperCase -> string {
        todo()
    }
    /// Returns true if the string starts with a given pattern.
    /// 
    /// ### Usage
    /// ```
    /// var name = "Joshua"
    /// assertThat(name.startsWith("J"))
    /// assertThat(name.startsWith("Jo"))
    /// ```
    public function startsWith(pat: string) -> boolean {
        var iterA = this.vec.iter()
        var iterB = pat.vec.iter()
        return iterA.zip(iterB).all(fn (tuple) tuple.a == tuple.b)
    }
    /// Creates a string with at least the specified capacity.
    /// ### Usage
    /// ```
    /// ```
    public static function withCapacity(capacity: i32) -> This {
        return string(Array(capacity))
    }
    /// Creates a string from an array of bytes.
    /// ### Usage
    /// ```
    /// ```
    public static function fromUtf8(vec: []i32) -> This {
        return string(vec)
    }
    /// Creates a string from a value that implements Display.
    /// ### Usage
    /// ```
    /// var value = 1234
    /// var valueStr = string.from(value)
    /// 
    /// assert(valueStr).equals("1234")
    /// ```
    public static function from<T implements Display>(value: T) -> This {
       return value.toStr()
    }
    /// Creates a new formattable string template.
    /// ### Usage
    /// ```
    /// var greeting = string.fmt("Hello, %!")
    /// var greetingStr = greeting.add("John").finish()
    /// 
    /// assert(greetingStr).equals("Hello, John!")
    /// ```
    public static function fmt(template: string) -> Template {
        return Template(template)
    }
}


/// A simple iterator over the characters in a string.
public model Chars implements Iterable<string> {
    var idx: i32
    var bytes: ArrayIter<i32>
    
    new(bytes: ArrayIter<i32>) {
        this.idx = 0
        this.bytes = bytes;
    }
    /// Returns the next character in the string.
    public function [Iterable.next] -> ?string {
        return nextCodePoint(this.bytes).map(fn(ch) string.fromUtf8([ch]))
    }
}

var CONT_MASK = 0b00111111

public function nextCodePoint(bytes: ArrayIter<i32>) -> ?i32 {
    // Decode UTF-8
    var x = bytes.next()?
    if x < 128 {
        return some(x)
    }

    // Multibyte case follows
    // Decode from a byte combination out of: [[[x y] z] w]
    // NOTE: Performance is sensitive to the exact formulation here
    var init = utf8FirstByte(x, 2)
    // SAFETY: `bytes` produces an UTF-8-like string,
    // so the iterator must produce a value here.
    var y = bytes.next().unwrap()
    var ch = utf8AccContByte(init, y)
    if x > 0xE0 {
        // [[x y z] w] case
        // 5th bit in 0xE0 .. 0xEF is always clear, so `init` is still valid
        // SAFETY: `bytes` produces an UTF-8-like string,
        // so the iterator must produce a value here.
        var z = bytes.next().unwrap();
        var y_z = utf8AccContByte((y & CONT_MASK), z);
        ch = init << 12 | y_z;
        if x >= 0xF0 {
            // [x y z w] case
            // use only the lower 3 bits of `init`
            // SAFETY: `bytes` produces an UTF-8-like string,
            // so the iterator must produce a value here.
            var w = bytes.next().unwrap() ;
            ch = (init & 7) << 18 | utf8AccContByte(y_z, w);
        }

    }

    some(ch)
}

function utf8FirstByte(byte: i32, width: i32) -> i32 {
    return (byte & (0x7F >> width))
}

/// Returns the value of `ch` updated with continuation byte `byte`.
function utf8AccContByte(ch: i32, byte: i32) -> i32 {
    ((ch << 6) | (byte & CONT_MASK))
}

/// Represents an interface for models that can be created from a string representation.
public interface FromStr {
    /// Parses a provided string and returns an instance of the implementing type.
    public static function fromStr(str: string) -> ?This
}