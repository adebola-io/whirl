module uInt8Array

use core.array.Array
use core.maybe.{some, none}
use core.memory.at;
use core.numeric.Int32
use core.sentinels.{todo, fatal}

import "internal:u8array" {
    /// Interpretes a block of unsigned 8-bit integers as an array of 32-bit numbers.
    "toArray" as function toInt32Array(offset: Int32, length: Int32, capacity: Int32) -> Array<Int32>;
}

public model UInt8Array {
    public var offset: Int32
    public var length: Int32
    public var capacity: Int32

    new(capacity: Int32) {
        // Capacity must be set first so the offset can be determined.
        this.capacity = capacity
        this.length = 0
        this.offset = core.sentinels.todo()
    }

    public function setValue(value: Int32, offset: Int32) {
        if offset > this.length {
            fatal(some("Offset cannot be greater than length of the array."))
        }
        todo()
    }

    public function at(index: Int32) -> ?Int32 {
        if index > this.length or index < 0 {
            return none()
        }
        var offset = this.offset + index
        return some(at(offset))
    }

    /// Converts the UInt8Array to an array of 32-bit integers so that it can be
    /// indexed into and iterated over.
    /// ### Usage
    /// ```
    /// 
    /// ```
    public function asArray -> Array<Int32> {
        todo()
    }

    public function append(other: UInt8Array) {
        
    }
} 